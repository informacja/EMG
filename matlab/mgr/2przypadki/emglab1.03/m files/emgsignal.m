function [s, t] = emgsignal (varargin)% Returns a signal segment with appropriate filtering.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net    global CURR EMG SETS EMGLAB    if nargin==0;        opt = 'get';    elseif ischar(varargin{1});        opt = varargin{1};        varargin(1) = [];    else        opt = 'get';    end;	switch opt;            case 'init';        EMG = struct ('data', [], 'nchannels', 0, 'source', [], 'thread', []);    case 'get'  % (t0, t1, iband, ichan)        nin = length(varargin);        if nin >= 4; ichan = varargin{4}; else ichan = CURR.chan; end;        if nin >= 3; iband = varargin{3}; else iband = CURR.band; end;        if ichan>0;            ithread = 1;            isig = ichan;            highpass = SETS.band(CURR.band).frequency;            lowpass = inf;        else            ithread = 2;            isig = 1;            highpass = SETS.auxiliary.highpass;            lowpass = SETS.auxiliary.lowpass;        end;        THREAD = EMG.thread(ithread);        dt = 1/THREAD.rate;        if nin >= 2;            t0 = varargin{1};            t1 = varargin{2};        else            t0 = EMG.start;            t1 = min (EMG.start + EMG.buffer_length, THREAD.start + THREAD.duration);        end;        t0 = round(t0*THREAD.rate)/THREAD.rate;        t1 = round(t1*THREAD.rate)/THREAD.rate;                if max(t0,THREAD.start) < THREAD.time ...                | min(t1,THREAD.start+THREAD.duration) > THREAD.time + EMG.buffer_length;            emgsignal ('load', ithread, t0, t1);        elseif length(THREAD.signal) < isig            emgsignal ('filter', ichan);        elseif THREAD.signal(isig).highpass ~= highpass | THREAD.signal(isig).lowpass ~= lowpass;            emgsignal ('filter', ichan);        end;        THREAD = EMG.thread(ithread);        if isempty(EMG.thread(ithread).buffer);            s = mksig ([], 0, dt);        elseif t1<t0;            s = mksig ([], t0, dt);        elseif ithread==2 | iband==CURR.band & ~isempty(EMG.thread(ithread).signal(isig).sig);  %%%& isig<=length(EMG.thread(ithread).signal);            s = sigseg (EMG.thread(ithread).signal(isig), t0, t1-t0);        elseif iband==1;            s = mksig (EMG.thread(ithread).buffer(:,isig), THREAD.time, dt);            s = sigseg (s, t0, t1-t0);            s.sig = double(s.sig) / THREAD.channel(isig).gain;        else            s = mksig (EMG.thread(ithread).buffer(:,isig), THREAD.time, dt);            s = sigseg (s, max(0, t0-.05), min(t1-t0+.1, THREAD.duration));            s = hpfilt (s, SETS.band(iband).frequency);            s = sigseg (s, t0, t1-t0);            s.sig = s.sig / THREAD.channel(isig).gain;        end;        if nargout==2;            t = s.t0 + [0:length(s.sig)-1]*s.dt;            s = s.sig;        end;            case 'connect'        if isempty(EMG.data); return; end;        [ichan, ithread] = deal (varargin{1:2});        init = nargin==4;        if ichan==0;            return;        elseif ichan>0;            isource = 1;            isig = ichan;        else            isource = 1-ichan;            isig = 1;        end;                   bl = max (emgprefs('buffer_length'), 1);        EMG.buffer_length = min (bl, EMG.duration);        S = EMG.source(isource);        if init;            t0 = EMG.start;        else            t0 = SETS.navigation.time;        end;        t1 = t0 + EMG.buffer_length;        if t1 > S.duration;            t1 = S.duration;            t0 = max(S.start, S.duration - EMG.buffer_length);        end;        s = struct ('sig', [], 't0', 0, 'dt', 1, 'highpass', -1, 'lowpass', inf);        t = struct ( ...            'name',         S.file.name, ...            'source',       isource, ...            'nchannels',    S.nchannels, ...            'channel',      S.channel(isig), ...            'duration',     S.duration, ...            'rate',         S.rate, ...            'start',        S.start, ...            'buffer',       [], ...            'signal',       s, ...            'time',         t0);          if ithread==1;            t.channel = S.channel;            EMGLAB.emg_file = t.name;            EMG.channel = t.channel;        else            EMGLAB.aux_file = t.name;        end;        if init;            EMG.thread = t;        else            EMG.thread(ithread) = t;        end;        status = emgfile ('buffer', ithread, t0, t1);        if ~status; return; end;        emgsignal ('filter', ichan);        if isempty (S.channel(isig).min);            if ichan>0;                s = EMG.thread(1).signal(ichan).sig;            else                s = EMG.thread(ithread).signal(1).sig;            end;            mins = min(s);            maxs = max(s);            EMG.source(isource).channel(isig).min = mins;            EMG.source(isource).channel(isig).max = maxs;        end;    case 'load'        [ithread, t0, t1] = deal (varargin{:});        THREAD = EMG.thread(ithread);        t0 = max (round(t0*THREAD.rate)/THREAD.rate, THREAD.start);        t1 = min (round(t1*THREAD.rate)/THREAD.rate, THREAD.start + THREAD.duration);        old_time = THREAD.time;        bl = round (EMG.buffer_length*THREAD.rate);        b0 = round (old_time * THREAD.rate);        b1 = round ((old_time + EMG.buffer_length)*THREAD.rate);        n0 = round (t0*THREAD.rate);        n1 = round (t1*THREAD.rate);        status = emgfile ('load', ithread, t0, t1);        if ~status; return; end;        for i=1:THREAD.nchannels;            EMG.thread(ithread).signal(i).highpass = -1;        end;        THREAD = EMG.thread(ithread);        if ithread == 1;            isig = CURR.chan;            highpass = SETS.band(CURR.band).frequency;            lowpass = inf;        else            isig = 1;            highpass = SETS.auxiliary.highpass;            lowpass = SETS.auxiliary.lowpass;        end;        oldsig = EMG.thread(ithread).signal(isig).sig;        for i=isig;            r = THREAD.rate;            f = lowpass/r;            if highpass > 0;                f = min (highpass/r, lowpass/r);            end;            if isinf(f);                npad2 = 0;            elseif f > 0;                npad2 = 2 / f;            else                npad2 = 100;            end;            npad2 = min (npad2, 10000);            npad = 2*npad2;            gain = THREAD.channel(i).gain;%            r = THREAD.rate; %           if highpass == 0; %               newsig = double (EMG.thread(ithread).buffer(:,i)) / gain;            if t0 <= old_time - EMG.buffer_length + npad | t0 > old_time + EMG.buffer_length - npad;                newsig = condition (EMG.thread(ithread).buffer(:,i), 0, gain, highpass/r, lowpass/r);             elseif t0 >= old_time;                nnew = min (n1, round(THREAD.duration*THREAD.rate)) - b1;                nold = bl-nnew+1;                s1 = condition (EMG.thread(ithread).buffer(end-nnew-npad+1:end,i), 0, gain, highpass/r, lowpass/r);                newsig = oldsig;                newsig(1:nold-1) = newsig(end-nold+2:end);                                           newsig(end-nnew-npad2+1:end) = s1(npad-npad2+1:end);            else                nnew = b0 - max(n0,0);                nold = bl - nnew + 1;                s1 = condition (EMG.thread(ithread).buffer(1:nnew+npad,i), 0, gain, highpass/r, lowpass/r);                newsig = oldsig;                newsig(end-nold+2:end) = newsig(1:nold-1);                newsig(1:nnew+npad2) = s1(1:nnew+npad2);            end;            s = mksig (newsig, THREAD.time, 1/THREAD.rate);            s.highpass = highpass;            s.lowpass = lowpass;            a = s; % workaround for 2006a            EMG.thread(ithread).signal(isig) = a;        end;    case 'filter'        if isempty(varargin);            ichan = CURR.chan;        else            ichan = varargin{1};        end;        if ichan>0;            isig = ichan;            ithread = 1;            highpass = SETS.band(CURR.band).frequency;            lowpass = inf;        else            isig = 1;            ithread = 2;            highpass = SETS.auxiliary.highpass;            lowpass = SETS.auxiliary.lowpass;        end;        THREAD = EMG.thread(ithread);        r = EMG.thread(ithread).rate;        if ~isempty(EMG.thread(ithread).buffer)            s = condition (EMG.thread(ithread).buffer(:,isig), 0, THREAD.channel(isig).gain, highpass/r, lowpass/r);            s = mksig (s, THREAD.time, 1./THREAD.rate);            s.highpass = highpass;            s.lowpass = lowpass;            a = s; % workaround for 2006a            EMG.thread(ithread).signal(isig) = a;        end;            	end;        function s = condition (s1, offset, gain, highpass, lowpass)        s = (double(s1) - offset) / gain;        if highpass > 0;            s = hpfilt (s, highpass);        end;        if lowpass < inf;            s = lpfilt (s, lowpass);        end;