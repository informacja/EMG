function emgevent (opt, p1, p2)% EMGlab function that handles the initial callback from all sources,%   and then calls emgdispatch, emgbutton, emgaction, or%   emgkeypress as appropriate.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net    global SCREEN    %%%%   try    switch lower(opt)        case 'timer'            emgbutton (SCREEN.TIMER.panel, SCREEN.TIMER.button);        case 'menucallback'            cbo = gcbo;            p = get(cbo, 'parent');            label = get(cbo, 'label');            if strcmp (get(p,'type'), 'uicontextmenu')                emgaction (label, get(p, 'user'));                SCREEN.down_click = [];                emgplot ('done');            elseif ~isempty(get(cbo, 'child'));                emgmenu (cbo);            else                emgaction ([label, get(cbo, 'tag')]);                emgplot ('done');            end;        case 'mousedown';            if SCREEN.play.running; return; end;            click = pointer_info ('down');            click.type = get (SCREEN.figure, 'selectiontype');            object = get (SCREEN.figure, 'currentobject');            click.object = get (object, 'tag');            click.params = get (object, 'user');            click.offset = 0;            click.moved = 0;            click.scrolled = 0;            click.drag = '';            SCREEN.down_click = click;            context_menu = get(object, 'uicontext');            stop (SCREEN.timer);            if strcmp (click.region, 'mcbutton');                set (click.handle, 'value', 1);                set (SCREEN.sprite.text, 'vis', 'off');                SCREEN.TIMER.button = get (click.handle, 'string');                SCREEN.TIMER.panel = get (click.handle, 'tag');                set (SCREEN.timer, 'Period', 0.2, 'executionmode', 'fixedspacing', ...                    'startdelay', 0.25, 'busymode', 'drop', ...                    'timerfcn', 'emgevent(''timer'')');                start (SCREEN.timer);            elseif ~isempty(context_menu);                set (context_menu, 'user', click.params);                SCREEN.down_click = [];                v = version;                if strcmp(computer,'MAC') & strcmp (v(1), '7');                    set(get(object,'uicontext'), 'pos', [click.x_pxls, click.y_pxls], 'vis','on');                    SCREEN.down_click = [];                end;            else                emgdrag ('down', click);            end        case 'mousemotion';            if isempty (SCREEN); return; end;            if SCREEN.play.running; return; end;            if isempty(SCREEN.down_click);                mouse = pointer_info ('move');                if strcmp (get(SCREEN.figure, 'pointer'), 'watch');                elseif strcmp (mouse.region, 'resize bar');                    set (SCREEN.figure, 'pointer', 'cross');                else                    set (SCREEN.figure, 'pointer', 'arrow');                end;                if strcmp (mouse.panel,'map')                    emgplot ('map text', mouse.x_units);                elseif strcmp (get(SCREEN.map.text, 'vis'), 'on');                    emgplot ('map text', nan);                end                if strcmp (mouse.region, 'mcbutton');                    stop (SCREEN.timer)                    set (SCREEN.timer, 'Period', 0.5, 'executionmode', 'singleshot', ...                        'startdelay', 0.5, 'timerfcn', 'emgevent(''tooltip'')');                    start (SCREEN.timer);                else                    set (SCREEN.sprite.text, 'string', ' ', 'vis', 'off');                end;            else                mouse = pointer_info ('drag');                set (SCREEN.map.text, 'string', '');                emgdrag ('drag', mouse);            end;        case 'mouseup';            if SCREEN.play.running; return; end;            stop (SCREEN.timer);            if isempty (SCREEN.down_click); return; end;            down_click = SCREEN.down_click;            SCREEN.down_click = [];            if strcmp(down_click.region, 'mcbutton');                set (down_click.handle, 'value', 0);                n = get(SCREEN.timer, 'tasksexecuted');                stop (SCREEN.timer);                if n==0;                    e = get(SCREEN.timer, 'timerfcn');                    eval(e);                end;            elseif down_click.scrolled;                emgdrag ('up', down_click);            else                emgdrag ('up', down_click);                up_click = pointer_info ('up');                emgdispatch (down_click, up_click);            end;            emgplot ('done');        case 'buttonpress'            panel = get (gcbo, 'tag');            button = get (gcbo, 'string');            emgbutton (panel, button);            figure(SCREEN.figure);  % gets back focus for keypress in 6.5            emgplot ('done');        case 'keypress'            if ~isfield (SCREEN, 'keypress');                SCREEN.keypress = struct ('busy', 0, 'timeout', clock);            end;            if ~SCREEN.keypress.busy | etime(clock, SCREEN.keypress.timeout) > 2;                SCREEN.keypress.busy = 1;                emgkeypress (p1, p2);                drawnow; % flushes queue                SCREEN.keypress.timeout = clock;                SCREEN.keypress.busy = 0;            else                % ignore queued calls during flush            end;        case 'scrollwheel'            if(p2.VerticalScrollCount>0)                emgbutton('signal','>');            elseif(p2.VerticalScrollCount<0)                emgbutton('signal','<');            end        case 'tooltip'            mouse = pointer_info ('move');            if strcmp (mouse.region, 'mcbutton');                h = SCREEN.sprite.text;                p = get (mouse.handle, 'pos');                set (h, 'string', get(mouse.handle, 'tooltip'));                e = get (h, 'extent');                x = p(1) - e(3) - 2;                if x < 0;                    x = p(1) + p(3) + 2;                end;                set (h, 'pos', [x, p(2) + p(4)/2], 'vis', 'on');            end;    end;%%%%    catch%       err = lasterror;%       %save the error in the log file%       %and create the error message%       [status, errMes] = emgerror(err);%       if EMGLAB.matlab_version < 7.1%           rethrow (err);%       elseif EMGLAB.matlab_version < 7.2%           error (err.identifier, errMes);%       elseif EMGLAB.matlab_version < 7.5%           fprintf (2, ['??? ',errMes]);%           rethrow(err);%       else%           error (err.identifier, errMes);%       end%   end;function info = pointer_info (action)    global SCREEN    window_position = get (SCREEN.figure, 'currentpoint');    x = window_position (1);    y = window_position (2);    info = struct ('x_pxls', x, 'y_pxls', y);    p = SCREEN.region_position;    in = x>=p(:,1) & x<=p(:,1)+p(:,3) & y>=p(:,2) & y<=p(:,2)+p(:,4);    region = SCREEN.region(min(find(in)));    if isempty(region);    info.region = 'none';        info.handle = [];    else        info.region = region.type;        info.handle = region.id;    end;    if strcmp (info.region, 'axes');        info.panel = get (info.handle, 'tag');    elseif strcmp (info.region, 'resize bar');        info.panel = [info.handle, '_resize_bar'];    else        info.panel = 'none';    end;    if strcmp (action, 'drag') & isempty(SCREEN.down_click);        ax = [];    elseif strcmp (action, 'drag') & strcmp (SCREEN.down_click.region, 'axes');        ax = SCREEN.down_click.handle;    elseif strcmp (info.region, 'axes');        ax = info.handle;    else        ax = [];    end;    if ishandle(ax);        xlim = get (ax, 'xlim');        ylim = get (ax, 'ylim');        lims = get (ax, 'user');        if isempty(lims); lims = [0,1,0,1]; end;        pointer_position = get (ax, 'currentpoint');        info.x_divs = pointer_position(1,1);        info.y_divs = pointer_position(1,2);        x_norm = (pointer_position(1,1) - xlim(1)) / (xlim(2) - xlim(1));        y_norm = (pointer_position(1,2) - ylim(1)) / (ylim(2) - ylim(1));        info.x_units = lims(1) + x_norm * (lims(2) - lims(1));        info.y_units = lims(3) + y_norm * (lims(4) - lims(3));    end;