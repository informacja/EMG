function slist = automerge (sig, slist, se90, nkeepers)% EMGlab function for automatic decomposition / template merging.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	if isempty (slist); return; end;    if nargin<4; nkeepers = 0; end;	min_separation = 0.0005;	max_separation = 0.04;	n_outs_allowed = 2;	muap_width = goodwidth (0.01, sig.dt);	lmuap = round(muap_width/sig.dt); 	nu = max(slist(:,2));    if nkeepers>=nu; return; end;		%	Extract full-length MUAPs.	muaps = sigseg (sig, slist(:,1), muap_width, 'c');	muaps = muaps.sig;	%	Compute templates, allowable misalignment errors, and numbers of occurrence.	id = slist(:,2);	for i=1:nu;		template = median( [muaps(:,id==i), zeros(lmuap,1)], 2);		template_tp = rtp (template);    	temp_tp(:,i) = template_tp;		align_error_tp = template_tp - hr_shift(template_tp,.4);		variability (i) =  sum(align_error_tp.^2); 		noccurrences(i) = sum(id==i);	end;%	Compute distance matrix between templates using global alignment.%	Keep track of the alignment offsets.	DistMat = inf*ones(nu,nu);	offset = zeros(nu,nu);	for i=1:nu-1;       for j=max(i+1, nkeepers+1):nu;					            [tempja, offset(i,j)] = hr_align(temp_tp(:,j),temp_tp(:,i),'g');			DistMat(i,j) = sum((temp_tp(:,i)-tempja).^2);		end;	end;%	Compute match threshold for each template%	from background noise error (weighted by numbers of occurrences)%	and allowable misalignment error (modeling MUAP variability).		matchThresh = se90*lmuap*(repmat(1./noccurrences',1,nu) + ...		repmat(1./noccurrences,nu,1)) + repmat(variability,nu,1);%	Set distance measures greater than threshold to inf.	DistMat(DistMat>matchThresh) = inf;    DistMat(isinf(matchThresh)) = inf;%	Merge loop.	while 1;		%		Find the pair of templates that match most closely.		[cmin, ic] = min(DistMat);		[minmin, j] = min(cmin);		if minmin == inf; break; end;		i = ic(j);		%		Combine their firing times, correcting for the alignment offset.		itimes = slist(slist(:,2)==i,1);		jtimes = slist(slist(:,2)==j,1) - offset(i,j)*sig.dt;		times = sort ([itimes; jtimes]);		%		If the combined train is valid, merge the two trains and mark the%		second train so it won't be tried again.%		Note that the ">5" allows multiple identifications of the same discharge.		intervals = diff(times);		n_outs = sum(intervals>min_separation & intervals<max_separation);		if n_outs < n_outs_allowed;			slist(slist(:,2)==j,1) = jtimes;			slist(slist(:,2)==j,2) = i;			DistMat(:,i) = min(DistMat(:,i), DistMat(:,j));			DistMat(i,:) = min(DistMat(i,:), DistMat(j,:));			DistMat(:,j) = inf;			DistMat(j,:) = inf;			DistMat(i,i) = inf;		end;	%		Mark to prevent trying this pair again.		DistMat(i,j) = inf;	end;%	Validation loop.  For each unit:	for iu = 1:nu;		ip = find(slist(:,2)==iu);        if ~isempty(ip);			%		Delete all multiple identifications of the same discharge. 		times = sort(slist(ip,1));		intervals = abs(diff(times));		times(intervals<min_separation) = [];		%		Recompute the template using alignment.				nmuaps = length(times);		[muaps, muaps_tp] = sigseg (sig, times, muap_width, 'c');		muaps = muaps.sig;		template = median(muaps,2);		template_tp = rtp (template);		aligned_muaps_tp = zeros (lmuap, nmuaps);		for k=1:nmuaps;			[aligned_muaps_tp(:,k), offset] = hr_align (muaps_tp(:,k), template_tp);			times(k) = times(k) - offset*sig.dt;		end;		aligned_muaps = irtp(aligned_muaps_tp);		template = median(aligned_muaps, 2);		template_tp = rtp(template);		%		Compute the hilbert window.  %		The zeros provide a kind of denoising to reduce the%		window to zero in areas where the template is just noise.		t2 = median([aligned_muaps, zeros(lmuap,ceil(nmuaps/2))],2);		h = envelope (t2);		%		Compute the allowable misalignment error with windowing.		dtemp = template_tp - hr_shift(template_tp,.4);		match_thresh = se90 + sum((irtp(dtemp).*h).^2);		%		Compute the squared error between each discharge and the template,%		using windowing.		d = irtp(muaps_tp-repmat(template_tp,1,nmuaps)).*repmat(h,1,nmuaps);		d = sum(d.^2);		%		Delete discharges that exceed the error threshold.        n_originally = length(times);        if nkeepers == 0;            ix = find (d > match_thresh);            times(ix) = [];            d(ix) = [];        end;		%		If two discharges are less than 40 ms apart, %		keep the one with the least error and delete the other one.		while any(diff(times)<max_separation);			k = min(find(diff(times)<max_separation));			[b,ix] = max(d(k:k+1));			d(k+ix-1) = [];			times(k+ix-1) = [];		end;%		Delete unit if less than half of the discharges remain		if ip > nkeepers & length(times) < n_originally / 2;			slist(ip,:) = [];			break;		end;		%		Re-align each discharge with the template, and update the slist.		slist(ip,:) = [];		slist = [slist; [times, ones(size(times))*iu]];                      end;%		End of Validation loop.	end;%	Re-sort the slist.%	Renumber the units and delete those with < 1 discharge per second.	k = nkeepers+1;	[b,ix] = sort(slist(:,1));	slist = slist(ix,:);	for i=nkeepers+1:nu;    	ii = find(slist(:,2)==i);		kk  = find(slist(:,2)>0 & slist(:,2)~=i);    	if length(ii)<length(sig.sig)*sig.dt;			slist(ii,2) = 0;		elseif linkcheck (slist(ii,1), slist(kk,:), muap_width/2);			slist (ii,2) = 0;		else        	slist(ii,2) = k*ones(size(ii));       	 	k = k + 1;    	end;	end;	slist(find(slist(:,2)==0),:) = [];function l = linkcheck (t1, slist, window);	l = 0;	nu = max(slist(:,2));	for i=1:nu;		t2 = slist(slist(:,2)==i,1);		if length(t2)>=length(t1);			d = t1 - nearest (t2, t1);			dm = median(d);			v = abs(d-dm);			if abs(dm)<window & median(v)<0.001;				l = 1;			end;		end;	end;