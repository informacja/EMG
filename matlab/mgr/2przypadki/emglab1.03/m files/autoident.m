function autoident ()% EMGlab function for automatic decomposition / spike classification.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	global SETS DECOMP CURR	if DECOMP.nunits == 0; return; end;	toks = [5,10,10];	vths = [5,10,15];    thrs = [.75,.625,.5];		for irun = 1:3;	TOK = toks(irun);	VTH = vths(irun);		[ms_noise, ss_temp, temp_var, temp_mask] = temp_variability;	[t0, t1] = whattime (SETS.firing);	signal = emgsignal (t0, t1);    thresh = inf;    for i=1:DECOMP.nunits;        thresh = min(thresh, thrs(irun)*max(abs(irtp(emgtemp(i)))));    end;	thresh = max(thresh, getthreshold (signal));	resid = emgresidual (t0, t1);	temp_width = SETS.band(CURR.band).temp_width;	dt = resid.dt;	len = round(temp_width/dt);	nunits = DECOMP.nunits;    m = double(abs(resid.sig)>thresh);	m = conv (m, ones(10,1)) > 0;	m = m(6:length(m)-4);	d = diff([0;m;0]);	iup = find(d>0)-1;	idn = find(d<0)-1;	iactive = floor((iup+idn)/2);	    mean_isi = zeros(DECOMP.nunits,1);    std_isi = zeros(DECOMP.nunits,1);    curr_vis = [DECOMP.unit(:).visible];	for i=1:DECOMP.nunits;		[mean_isi(i), std_isi(i)] = firingstats (emgslist(i));        DECOMP.unit(i).visible =  curr_vis(i) & (ss_temp(i) > ms_noise*len);	end;    resolve = length(emgslist(0,t0,t1)) > 0.8 * sum(1./mean_isi)*(t1-t0);		for iseg = 1:length(iactive);		t = resid.t0 + (iactive(iseg)-1)*resid.dt;		snap0 = emgsnapshot ('snap', t, signal);		[res, sig] = emgsnapshot ('waves', snap0);		ss_res = sum (res.sig.^2);		ss_sig = sum (sig.sig.^2);		if ss_res < ms_noise * len; break; end;        comp = snap0.comp;		ix = find ([comp(:).visible]);		units = [comp(ix).unit];		duplicates = any(diff(sort(units))==0);		badmatch = ss_res > ss_sig - 0.5*sum(ss_temp(units));		if duplicates | badmatch;            emgsnapshot ('delete component', snap0, ix);			emgsnapshot ('update slist', snap0);			ss_res = ss_sig;		end;          %      snapa = emgsnapshot ('align', snap0);  %      r = emgsnapshot ('waves', snapa);  %      ss_r = sum(r.sig.^2);  %      if ss_r < ms_noise * len;  %          emgsnapshot ('update slist', snapa);  %          fprintf ('yo\n');  %          break;  %      end;                		timing_factor = zeros(nunits, 1);		for iu = 1:nunits;			if any([comp(:).unit]==iu)				p = inf;			else				firing_times = emgslist(iu);				tau = abs (t - nearest(firing_times, t));				p = 1;				if tau < 1.7 * mean_isi(iu);					p = ( (tau - mean_isi(iu)) / std_isi(iu)) ^2;				end;			end;			timing_factor(iu) = p;		end;		go = 1;		snap1 = snap0;         avar = 0*res.sig + ms_noise;		while go;			best_unit = 0;			ss_best = inf;			ss_possible = ss_res + ss_temp - 2*sqrt(ss_res * ss_temp);			[b, ix] = sort (ss_possible);			for i=1:nunits;				iu = ix(i);                if ~DECOMP.unit(iu).visible;                elseif ss_possible(i) > ss_best & ~resolve					break;				elseif timing_factor(iu) < TOK;					snap2 = emgsnapshot ('add unit', snap1, iu);                    if resolve;                        snap2 = emgsnapshot ('resolve', snap2);                    end;					res2 = emgsnapshot ('waves', snap2);					ss_res2 = sum(res2.sig.^2);					if ss_res2 < ss_best						best_unit = iu;						ss_best = ss_res2;						best_snap = snap2;						best_res = res2.sig.^2;					end;                end;			end;			if best_unit == 0; break; end;            			ix = find([best_snap.comp(:).unit]==best_unit);			d = best_snap.comp(ix).time - best_snap.t0;			var = hr_shift (temp_var(:,best_unit), d/dt);			avar = avar + abs(irtp(var));			mask = shiftt (temp_mask(:,best_unit), d/dt);			match_error = sum(best_res./avar.*mask) / sum (mask);			reduction = (ss_res - ss_best) / ss_temp(best_unit);                            %%			if reduction > 0.5 & match_error < VTH;            if reduction > 0 & match_error < VTH;				n0 = length(snap0.comp);				n2 = length(best_snap.comp);				for i=n2:-1:n0+1;					iu = best_snap.comp(i).unit;					d = best_snap.comp(i).time - best_snap.t0;					var = hr_shift (temp_var(:,iu), d/dt);					var = abs(irtp(var)) + ms_noise;					mask = shiftt(temp_mask(:,iu), d/dt);					match_error = sum(best_res./var.*mask) / sum(mask);					if match_error < VTH;						emgplot ('discharge', iu, best_snap.comp(i).time);                    else                        best_snap = emgsnapshot ('delete component', best_snap, i);					end;				end;				emgsnapshot ('update slist', best_snap);				go = 0;			elseif reduction > 0.25;				snap1 = best_snap;				ss_res = ss_best;				timing_factor(best_unit) = inf;			else				go = 0;			end;		end;	end;    for i=1:DECOMP.nunits;        DECOMP.unit(i).visible = curr_vis(i);    end;	end;    															function [ms_noise, ss_temp, variability, mask] = temp_variability ()	global SETS EMG DECOMP CURR		NRUN = 2;	[s0, s1] = whattime (SETS.firing);	    l = s1-s0;    n = length(emgslist(0,s0,s1));    if length(emgslist(0,s0-l,s1-l)) > 1.25*n;        t0 = s0 - l;        t1 = s1 - l;    elseif length(emgslist(0,s0+l,s1+l)) > 1.25*n;        t0 = s0 + l;        t1 = s1 + l;    else        t0 = s0;        t1 = s1;    end;	signal = emgresidual (t0, t1);	temp_width = SETS.band(CURR.band).temp_width;	len = round(temp_width * EMG.rate);		ms_noise = median(signal.sig.^2);		nunits = DECOMP.nunits;	se_var = zeros(len,nunits);	mask  = zeros (len,nunits);	ss_temp = zeros(nunits,1);		for iu = 1:nunits;		temp = irtp(emgtemp (iu));		thresh = max(sqrt(ms_noise)*2, .01*max(abs(temp)));		ix = double(abs(temp)>thresh);		if sum(ix)>10;			c = conv(ones(NRUN,1), ix);			f = find(c==NRUN);			i1 = max(1,min(f)-NRUN);			i2 = min(length(temp), max(f));		else			i1 = round(0.25*len);			i2 = round(0.75*len);		end;		mask(i1:i2,iu) = 1;		ss_temp(iu) = sum(temp(i1:i2).^2);				u = emgslist (iu, t0, t1);		if length(u)>8;			w = sigseg (signal, u, temp_width, 'c');			w = (median(w.sig.^2,2) - 3*ms_noise) .* mask(:,iu);		else			w = ((temp*.05).^2 - 3*ms_noise) .* mask(:,iu);		end;		w(w<0) = 0;		variability(:,iu) = rtp(w);	end;