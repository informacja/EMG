function [x1, x2, x3] = emgsnapshot (opt, p1, p2, p3);% Manages a snapshot of the signal and its associated discharges% (as in the closeup panel).% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	global CURR SETS EMG DECOMP      	switch lower(opt)        		case 'snap';  % ss = f ('snap', time, [signal]);		time = round(p1*EMG.rate)/EMG.rate;		width = SETS.band(CURR.band).temp_width;        if nargin==2;            signal = emgsignal (time-width, time+width);        else            signal = p2;        end;		wave = sigseg (signal, time, width, 'c');    	sl = emgslist (0, time-0.8*width, time+0.8*width);        comp = struct('time', 0, 'unit', 0, 'visible', 0, 'color', 0);        comp(1) = [];        n = 0;		for i=1:size(sl,1);            iu = sl(i,2);            n = n+1;            comp(n).time = sl(i,1);            comp(n).unit = sl(i,2);            comp(n).visible = DECOMP.unit(iu).visible & sl(i,1)>time-0.4*width & sl(i,1)<time+0.4*width;            comp(n).color = mod (n-1, size(SETS.colors.waves,1)) + 1;   		end;		x1 = struct ('t0', time, 'width', width, 'wave', wave, 'comp', comp, ...            'filter', SETS.band(CURR.band).frequency);       	case 'unit'; % ss = f ('snip', unit);		width = SETS.band(CURR.band).temp_width;		t = emgtemp(p1);		t0 = -floor(length(t)/2)/EMG.rate;		wave = mksig (irtp(t), t0, 1/EMG.rate);		x1 = struct ('t0', 0, 'width', width, 'wave', wave, 'comp', [], 'unit', p1, ...            'filter', SETS.band(CURR.band).frequency);	case 'filter'; % ss = f ('filter', ss);		ss = p1;		if isempty(ss);            x1 = ss;            return;        elseif isfield (ss, 'unit');            x1 = emgsnapshot ('unit', ss.unit);            x1.comp = ss.comp;            return;        end;		width = SETS.band(CURR.band).temp_width;		ss.wave = sigseg (emgsignal, ss.t0, width, 'c');        if width > ss.width;            sl = emgslist (0, ss.t0-0.8*width, ss.t0+0.8*width);            if ~isempty(sl);                i = find(sl(:,1)>ss.t0-0.8*ss.width & sl(:,1)<ss.t0+0.8*ss.width);                sl(i,:) = [];            end;            for i=1:size(sl,1);                iu = sl(i,2);                c =  emgsnapshot('color', ss);                ss.comp(end+1).time = sl(i,1);                ss.comp(end).unit = sl(i,2);                ss.comp(end).visible = sl(i,1)>ss.t0-0.4*width & sl(i,1)<ss.t0+0.4*width;                ss.comp(end).color = c;            end;        elseif width < ss.width;            t = [ss.comp(:).time]';            i = find(t<ss.t0-0.8*width | t>ss.t0+0.8*width);            ss.comp(i) = [];         end;        ss.width = width;        ss.filter = SETS.band(CURR.band).frequency;		x1 = ss;			case 'update slist'; % f ('update slist', ss);		ss = p1;        comp = ss.comp;		emgslist ('delete', ss.t0 - 0.8*ss.width, ss.t0 + 0.8*ss.width);        slist = [[comp(:).time]', [comp(:).unit]'];		emgslist ('concat', slist);			case 'waves';  % [resid, sig, recon] = f ('waves', ss);         if p1.filter ~= SETS.band(CURR.band).frequency;            p1 = emgsnapshot ('filter', p1);        end;		ss = p1;		if ~isstruct(ss); x1=[]; x2=[]; x3=[]; return; end;		comp = ss.comp;		s  = ss.wave; 		resid = s;		for i=1:length(comp);			x = emgtemp (comp(i).unit, 'interp');			resid = super (resid, x, comp(i).time, -1);			if ~comp(i).visible;				s = super (s, x, comp(i).time, -1);			end;            		end;		recon = s;		recon.sig = s.sig - resid.sig;		[x1, x2, x3] = deal (resid, s, recon);       			case 'add unit'; % ss = f ('addunit', ss, unit, [time]);               if p1.filter ~= SETS.band(CURR.band).frequency;            p1 = emgsnapshot ('filter', p1);        end;		[ss, unit] = deal (p1, p2);		resid = emgsnapshot ('waves', ss);		resid = rtp (resid.sig);		temp = emgtemp (unit);        n = length(ss.comp)+1;        col = emgsnapshot ('color', ss);		if nargin>=4;             ss.comp(n).time = p3;            ss.comp(n).unit = unit;            ss.comp(n).visible = 1;            ss.comp(n).color = col;			ss = emgsnapshot ('align', ss);		else			[temp, d] = hr_align (temp, resid, 'g');            ss.comp(n).time = ss.t0 + d/EMG.rate;            ss.comp(n).unit = unit;            ss.comp(n).visible = 1;            ss.comp(n).color = col;		end; 		x1 = ss;			case 'add best unit'; % ss = f ('addbestunit', ss);        if p1.filter ~= SETS.band(CURR.band).frequency;            p1 = emgsnapshot ('filter', p1);        end;		ss = p1;		resid = emgsnapshot ('waves', ss);		resid = rtp (resid.sig);		ebest = norm(resid);		ibest = 0;		for i=1:DECOMP.nunits;            if DECOMP.unit(i).visible;                [temp, d] = hr_align (emgtemp(i), resid, 'g');                e = norm(temp-resid);                if e<ebest;                    ebest = e;                    ibest = i;                    dbest = d;                end;            end;		end;		if ibest>0;            n = length(ss.comp)+1;			ss.comp(n) = struct ('time', ss.t0+dbest/EMG.rate, 'unit', ibest, ...                'visible', 1, 'color', emgsnapshot('color', ss));		end;		x1 = ss;			case 'delete unit'; % ss = f ('delete unit', ss, unit);		ss = p1;		if ~isempty(ss)             for i=length(ss.comp):-1:1;                if ss.comp(i).unit==p2;                    ss.comp(i)=[];                elseif ss.comp(i).unit>p2                    ss.comp(i).unit = ss.comp(i).unit-1;                end;            end;        end;		x1 = ss;	    case 'delete component'        ss = p1;        if ~isempty(ss)            ss.comp(p2) = [];        end;        x1 = ss;    case 'show/hide'        ss = p1;        if ~isempty(ss);            ss.comp(p2).visible = ~ss.comp(p2).visible;        end;        x1 = ss;	case 'shift'; 		ss = p1;		if ~isempty(ss)             for i=1:length(ss.comp);                if ss.comp(i).unit==p2;                    ss.comp(i).time  = ss.comp(i).time - p3;                end;            end;        end;		x1 = ss;	case 'reorder'; % ss = f ('reorder', ss, new_order);		ss = p1;		if ~isempty(ss) 			map(p2) = [1:max(p2)];            for i=1:length(ss.comp);                ss.comp(i).unit = map(ss.comp(i).unit);            end;        end;		x1 = ss;			case 'align'; % ss = f ('align', ss);                if p1.filter ~= SETS.band(CURR.band).frequency;            p1 = emgsnapshot ('filter', p1);        end;		ss = p1;       		comp = ss.comp;		[b,s]  = emgsnapshot ('waves', ss);        %ss.wave;         ix = find([comp(:).visible]>0 & ~isnan([comp(:).time]));		if ~isempty(ix);			temps = emgtemp ([comp(ix).unit], 'tp', 0, 0, CURR.band);            			d = ([comp(ix).time]-ss.t0)*EMG.rate;            			a = resolve (rtp(s.sig), temps, d);             for i=1:length(ix);                ss.comp(ix(i)).time = ss.t0 + a(i)/EMG.rate;            end;		end;         		x1 = ss;	   	case 'resolve'; % ss = f ('align', ss);              if p1.filter ~= SETS.band(CURR.band).frequency;            p1 = emgsnapshot ('filter', p1);        end;		ss = p1;		comp = ss.comp;        if ~isempty(comp);%		s  = ss.wave;		[b,s]  = emgsnapshot ('waves', ss);		ix = find([comp(:).visible]>0 & ~isnan([comp(:).time]));   		if ~isempty(ix);			d = ([comp(ix).time]-ss.t0)*EMG.rate;			temps = hr_shift(emgtemp ([comp(ix).unit]), d);          			a = resolve (rtp(s.sig), temps);            for i=1:length(ix);                ss.comp(ix(i)).time = comp(ix(i)).time + a(i)/EMG.rate;            end;		end;        end;		x1 = ss;            case 'color' % ss = f ('color', ss);        ss = p1;        x1 = 1;        if isempty(ss); return; end;        if isempty(ss.comp); return; end;        i = find(~isnan([ss.comp(:).time]));        h = hist ([ss.comp(i).color], [1:size(SETS.colors.waves,1)]);        x1 = min(find(h==min(h)));       			end;