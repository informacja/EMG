function emgdrag (opt, where)	% EMGlab function that handles dragging events.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net		global SETS DECOMP CURR SCREEN        switch lower(opt);        % Down click        case 'down'               SCREEN.down_click.auto = 0;        SCREEN.down_click.drag  = 'none';        switch lower (where.panel);        case 'signal'            if ~strcmp (where.object, 'emg signal') & ~strcmp (where.object, 'resid');                                [t0, t1] = whattime (SETS.closeup);                t = where.x_units;                if (t>=t0 & t<=t1);                    SCREEN.down_click.drag = 'cursor';                    SCREEN.down_click.offset = (t1+t0)/2 - t;                    SCREEN.down_click.focus = 'closeup';                else                    S = SETS.firing;                    SCREEN.down_click.offset = where.x_units - S.left * S.timebase;                    SCREEN.down_click.drag = 'panel';                end;                return;            end;            w = emgprefs('template_width');            x = get(SCREEN.signal.signal, 'xdata');            a = get(SCREEN.signal.axes, 'user');            x1 = (x - SETS.signal.left) / (SETS.signal.right - SETS.signal.left);            x1 = a(1) + x1*(a(2) - a(1));            if strcmp (get(SCREEN.signal.resid, 'vis'), 'on');                y = get(SCREEN.signal.resid, 'ydata');                if ~isnan(y);                    s = get(SCREEN.signal.signal, 'ydata');                    [b,i] = min (abs(x1-where.x_units));                    if abs(s(i)-where.y_divs) < abs(y(i)-where.y_divs);                        y = y - y(i) + s(i);                    end;                else                    y = get(SCREEN.signal.signal, 'ydata');                end;            else                y = get(SCREEN.signal.signal, 'ydata');             end;            c = .5*get (SCREEN.signal.signal, 'color') + .5*SETS.colors.panel; 			i = find(x1 > where.x_units - w/2 & x1 < where.x_units + w/2);            [x, y, px, py] = convert_to_sprite (SCREEN.signal.axes, x(i), y(i));            SCREEN.down_click.sprite = [x(:)-where.x_pxls, y(:)-where.y_pxls];            set (SCREEN.sprite.signal, 'color', c, 'erase', 'xor', 'linewidth', 2);            SCREEN.down_click.drag = 'sprite';            SCREEN.down_click.scale = [px, py];         case 'template';            if strcmp (where.object, 'unit'); return; end;            S = SETS.template;            nrows = ceil (S.display / 10);            ncols = mod (S.display-1, 10) + 1;            y = where.y_divs/S.top/2 + .5;            row = ceil ((1-y) * nrows) -1; % zero based            col = ceil (where.x_divs/10 * ncols) - 1;  % zero based            iu = row*ncols + col + 1;                        if iu < 0 | iu > DECOMP.nunits; return; end;            x = get(SCREEN.template.signal(iu), 'xdata');            y = get(SCREEN.template.signal(iu), 'ydata');            k = find(isnan(x));            if ~isempty(k);                x = x(1:k(1)-1);                y = y(1:k(1)-1);            end;            y = y - mean(y) + where.y_divs;                        c = .5*get(SCREEN.template.signal(iu), 'color') + .5*SETS.colors.background;            [x, y, px, py] = convert_to_sprite (SCREEN.template.axes, x, y);            SCREEN.down_click.sprite = [x(:)-where.x_pxls, y(:)-where.y_pxls];            set (SCREEN.sprite.signal, 'color', c, 'erase', 'xor', 'linewidth', 2);            SCREEN.down_click.drag = 'sprite';            SCREEN.down_click.scale = [px, py];                    case 'tempcursor'            SCREEN.down_click.focus = 'template';            SCREEN.down_click.drag = 'vcursor';            SCREEN.down_click.offset = where.y_units - SETS.template.first_unit;                      case 'firing'            [t0, t1] = whattime (SETS.signal);            t = where.x_units;            if (t>=t0 & t<=t1);                SCREEN.down_click.offset = t0 - t;                SCREEN.down_click.focus = 'signal';                SCREEN.down_click.drag = 'cursor';            else                S = SETS.firing;                SCREEN.down_click.offset = where.x_units - S.left * S.timebase;                SCREEN.down_click.drag = 'panel';           end;                    case 'closeup';              emgvault ('mark');             if ~strcmp (SCREEN.down_click.object, 'unit');                 S = SETS.closeup;                SCREEN.down_click.offset =  where.x_units - S.left * S.timebase;      %          SCREEN.down_click.drag = 'panel';                return;             end;            iu = SCREEN.down_click.params;            if isempty(DECOMP.closeup); return; end;            comp = DECOMP.closeup.comp;            if comp(iu).visible;                 SCREEN.down_click.offset = comp(iu).time - where.x_units;                 SCREEN.down_click.drag = 'closeup';            end;        case 'navigation';               t = where.x_units;            if where.y_divs > - 0.3                [t0, t1] = whattime (SETS.signal);                SCREEN.down_click.focus = 'signal';            else                [t0, t1] = whattime (SETS.firing);                SCREEN.down_click.focus = 'firing';            end;            if t>t0 & t<t1;                SCREEN.down_click.offset = t0 - t;                SCREEN.down_click.drag = 'cursor';            else                S = SETS.navigation;                SCREEN.down_click.offset = where.x_units - S.left * S.timebase;                SCREEN.down_click.drag = 'panel';           end;                                 case 'map'            [t0, t1] = whattime (SETS.navigation);            SCREEN.down_click.offset = t0 - where.x_units;            SCREEN.down_click.focus = 'navigation';            SCREEN.down_click.drag = 'cursor';        case {'sig_resize_bar', 'tmp_resize_bar'}            x = get (SCREEN.sprite.axes, 'xlim');            set (SCREEN.sprite.signal, 'color', SETS.colors.graticule, 'erase', 'xor');            SCREEN.down_click.sprite = ...                [[x(1)-x(2); x(2)-x(1)], [0; 0]];            SCREEN.down_click.drag = 'resize_bar';        case 'fir_resize_bar'            y = get(SCREEN.sprite.axes, 'ylim');            set (SCREEN.sprite.signal, 'color', SETS.colors.graticule, 'erase', 'xor');            SCREEN.down_click.sprite = ...                [[0; 0], [y(1)-y(2); y(2)-y(1)]];                SCREEN.down_click.drag = 'resize_bar';        end            % Auto scroll            case 'auto'; %       get (SCREEN.figure, 'selectiontype');        emgcursors ('focus', SCREEN.down_click.focus, SCREEN.TIMER.button);              % Drag    case 'drag'                        if strcmp (CURR.animation, 'off'); return; end;        SCREEN.down_click.moved = 1;        click = SCREEN.down_click;        switch  click.drag;                         case 'sprite'                 x = click.sprite(:,1);                y = click.sprite(:,2);                if strcmp (where.region, 'axes');                    ax = where.handle;                    pan_pos = get (ax, 'pos');                    u = get (ax, 'user');                    if ~isempty(u);                        px = pan_pos(3) / (u(2) - u(1));                        py = pan_pos(4) / (u(4) - u(3));                        x = x / click.scale(1) * px;                        if ~strcmp (where.panel, 'firing') & ~strcmp (where.panel, 'map');                            y = y / click.scale(2) * py;                        end;                    end;                end;                set (SCREEN.sprite.signal, 'xdata', x+where.x_pxls, 'ydata', y+where.y_pxls, 'vis', 'on', 'erase', 'xor');                           case 'resize_bar'                 x = click.sprite(:,1);                y = click.sprite(:,2);                set (SCREEN.sprite.signal, 'xdata', x+where.x_pxls, 'ydata', y+where.y_pxls, 'vis', 'on', 'erase', 'xor');                            case 'closeup';                iu = click.params;                DECOMP.closeup.comp(iu).time =  where.x_units + click.offset;                emgplot ('closeup signals', iu);  %%%              SCREEN.down_click.dragged = 1;            case 'cursor'                SCREEN.down_click.scrolled = 1;                S = getfield (SETS, click.panel);                C = getfield (SETS, click.focus);                if where.x_divs*S.timebase + C.left*C.timebase + click.offset <  S.left*S.timebase;                    SCREEN.TIMER.button = '<';                    SCREEN.down_click.drag = 'auto';                elseif where.x_divs*S.timebase + C.right*C.timebase + click.offset > S.right*S.timebase;                    SCREEN.TIMER.button = '>';                    SCREEN.down_click.drag = 'auto';                end;                if strcmp (SCREEN.down_click.drag, 'auto');                    set (SCREEN.timer, 'Period', 0.05, 'executionmode', 'fixedspacing', ...                        'startdelay', 0.05, 'busymode', 'drop', ...                         'timerfcn', 'emgdrag(''auto'');');                    start (SCREEN.timer);                else                    emgcursors ('focus', click.focus, 'z', where.x_units + click.offset);           %%%                   SCREEN.down_click.dragged = 1;                end;                            case 'vcursor'                SCREEN.down_click.scrolled = 1;                S = getfield (SETS, click.panel);                C = getfield (SETS, click.focus);                emgcursors ('focus', click.focus, 'z', ceil(where.y_units - click.offset));          %%%                SCREEN.down_click.dragged = 1;                                          case 'panel'                SCREEN.down_click.scrolled = 1;                S = getfield (SETS, click.panel);                    t = click.offset - (where.x_divs - S.left) * S.timebase;                emgcursors ('focus', click.panel, 'z', t);   %%%             SCREEN.down_click.dragged = 1;             case 'auto'                S = getfield (SETS, click.panel);                C = getfield (SETS, click.focus);                if where.x_divs*S.timebase + C.left*C.timebase + click.offset >  S.left*S.timebase ...                    & where.x_divs*S.timebase + C.right*C.timebase + click.offset < S.right*S.timebase;                    stop (SCREEN.timer);                    SCREEN.down_click.drag = 'cursor';                end;        end;                % Up        case 'up'        if strcmp (CURR.animation, 'off'); return; end;        click = where;        if ~click.moved; return; end;        switch  click.drag;                        case 'sprite'                 set (SCREEN.sprite.signal, 'vis', 'off');                                            case 'resize_bar'                 set (SCREEN.sprite.signal, 'vis', 'off');                            case 'closeup';                            otherwise                switch click.panel                case 'navigation'                    emgplot ({'navigation cursors', 'firing cursors'});                case 'signal'                    emgplot  ({'signal cursor', 'firing cursors', 'navigation cursors'});                case 'tempcursor'                    emgplot ('template cursor');                case 'firing'                    emgplot ({'firing cursors', 'navigation cursors'});                %ZDT 05/28/09 fix for map text added the case                 case 'map'                    emgplot('mapcursor');                end            end;                 end;                function [x, y, px, py] = convert_to_sprite (ax, x, y);            pan_pos = get (ax, 'pos');    xlim = get (ax, 'xlim');    ylim = get (ax, 'ylim');    pxls_per_xunit = pan_pos(3) / (xlim(2) - xlim(1));    pxls_per_yunit = pan_pos(4) / (ylim(2) - ylim(1));    x = pan_pos(1) + (x - xlim(1)) * pxls_per_xunit;    y = pan_pos(2) + (y - ylim(1)) * pxls_per_yunit;    u = get (ax, 'user');    px = pan_pos(3) / (u(2) - u(1));    py = pan_pos(4) / (u(4) - u(3));