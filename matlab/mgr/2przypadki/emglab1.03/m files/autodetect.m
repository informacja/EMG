function [slist, msnoise] = autodetect (sig, resid, detectThresh)% EMGlab function for automatic decomposition / creating new templates.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	min_separation = 0.04;%	Detect spikes, register them, compute distance matrix		spike_width = goodwidth (0.002, sig.dt);	spike_times = findpeaks (resid, detectThresh, spike_width);    if isempty(spike_times); slist = []; msnoise = 0; return; end;	[spikes, spikes_tp] = sigseg (resid, spike_times, spike_width, 'c');	[spikes_tp, offset] = hr_align (spikes_tp);	spikes = irtp (spikes_tp);	spike_times = spike_times - offset'*sig.dt;	nspikes = length(spike_times);	DistMat = distmat (spikes_tp);%	Get background noise sample by taking non-spike part of signal.	lt = floor (spike_width/sig.dt);	x = double(abs(resid.sig) > detectThresh);	x = conv(x,ones(lt,1));	x = x(floor(lt/2)+1:floor(lt/2)+length(resid.sig));	x = resid.sig(x==0);	n = floor(length(x)/lt);	x = reshape(x(1:lt*n),lt,n); %	Compute sample distributions from background noise%	sse: sum of squared values (over spike-length window)	sse = sort(sum(x.^2));		sse90 = sse(round(.9*n));		% 90% percentile of sse	sse95 = sse(round(.95*n));  	% 95% percentile of sse	msnoise = sse90/lt;	%	Estimate MUAP variability by the misalignment error %	resulting from 0.2 sample misalignment	alignment_error_tp = spikes_tp - hr_shift (spikes_tp, .2);	sse_var = sum(alignment_error_tp.^2);%	Calculate the two matching thresholds.	%	The factor 2 is because the distance measure involves a %		subtraction	which doubles the noise variance.		near_thresh = 2*sse90 + repmat (sse_var, length(sse_var), 1);	wide_thresh = 2*sse95 + sse_var;%	Perform the clustering.		nclasses = 0;	spike_id = zeros(nspikes,1);	while 1;		%		Find the spike with the most nearby neighbors.		nnear = sum(DistMat < near_thresh);		if max(nnear)==0; break; end;		[b, iproto] = max(nnear);		%		Find all the spikes in the nearby neighborhood.	%		Determine the prototype template.%		Determine the hilbert window and the match threshold		inear = find( DistMat(:,iproto) < near_thresh(:,iproto) );		template = median (spikes(:,inear),2);		h = envelope (template);		match_thresh = sse95/lt + ...			sum((irtp(alignment_error_tp(:,iproto)).*h).^2); %		Include neigbors of neighbors in a wider neighborhood.%		Note: the factor 4 is not based on theory but it %		makes the wider neighborhood even wider.				k = zeros(length(DistMat),1);		for i=1:length(inear);			k = k | (DistMat(:,inear(i))<wide_thresh(iproto)*4);		end;		iwide = find(k);		nwide = length(iwide);%		Compute windowed distance between each spike in the wide%		neighborhood and the prototype template.				d = spikes(:,iwide) - repmat(template,1,nwide);		d = d .* repmat(h,1,nwide);		d = sum(d.^2);%		Find all the spikes in the wider neighborhood that meet%		the windowed criterion.		imatch = iwide(find(d<match_thresh));		nmatch = length(imatch);%		Split templates.%		If any intervals are less than 40 ms, peform maximum linkage clustering%		after setting the distance measure between too-close spikes to inf.				times = spike_times(imatch);		if sum(diff(times) < min_separation) > 0;			e1 = distmat (spikes_tp(:,imatch));			e2 = repmat(times,1,nmatch)-repmat(times',nmatch,1);			e2(abs(e2)<min_separation) = inf;			e2(~isinf(e2)) = 0;			p = cluster(e1+e2,'max');			subclasses = cut (p, wide_thresh(iproto));		else			subclasses = {[1:length(imatch)]'};		end;%		Mark the prototype spike to prevent it from being tried again.		DistMat(iproto,:) = inf;		DistMat(:,iproto) = inf;	%		Mark all the spikes in each subclass.		for i=1:length(subclasses);			nclasses = nclasses + 1;			ix = imatch(subclasses{i});			spike_id(ix) = nclasses;			DistMat(ix,:) = inf;			DistMat(:,ix) = inf;			template = median(spikes (:,ix),2);			tempEnergy(nclasses) = sum(template.^2);		end;	%		End of clustering loop	end;%	Sort by energy, check that the unit doesn't duplicate an%	existing unit, and assemble the slist.	muap_width = goodwidth (0.01, sig.dt);	    min_occurrences = length(sig.sig) * sig.dt;	[b,ix] = sort(tempEnergy);	n = 0;	slist = [];	for i = length(ix):-1:1;		iclass = ix(i);		k = find(spike_id == iclass);		if length(k) > min_occurrences;			t = spike_times(k);			m1 = sigseg (sig, t, muap_width, 'c');			m1 = median (m1.sig, 2);			m2 = sigseg (resid, t, muap_width, 'c');			m2 = median (m2.sig, 2);			if sum(m1.^2) <= sum(m2.^2) + length(m1)*msnoise;				n = n + 1;				slist = [slist; t, n*ones(size(k))];			end;		end;	end;	if ~isempty(slist);		[b,i] = sort(slist(:,1));		slist = slist(i,:);	end;% 	