function emgaction (opt, p1, p2)% EMGlab function that implements gui commands.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.netglobal SETS DECOMP EMGLAB CURR EMG SCREENemgplot ('busy')switch lower(opt);    case 'init'        EMGLAB.time=clock;        EMGLAB.emg_file = [];        EMGLAB.aux_file = [];        v = sscanf(version, '%i.%i.%i');        EMGLAB.matlab_version = v(1)+v(2)/10+v(3)/100;        EMGLAB.clipboard = [];        emgstatus ('init');    case 'about emglab...';        msgbox ({'EMGlab version 1.03.', ...            'www.emglab.net', ...            ' ', ...            'This work is licensed under the', ...            'Aladdin free public license.'}, ...            'About EMGlab');    case 'load emg file';        if ~dirty_check; return; end;        if ~emgdfile ('open'); return; end;        emgstatus ('new signal');        emgplot;    case 'import emg signal';        if ~dirty_check; return; end;        try            my_emgsignal;        catch        end;        if ~emgdfile ('import'); return; end;        emgstatus ('new signal');        emgplot;        	case 'load auxiliary file'        if ~emgdfile ('open aux'); return; end;        emgsettings ('get aux settings');        emgplot;        	case 'import auxiliary signal'        if ~emgdfile ('import aux'); return; end;        SETS.signal.aux = 1;        SETS.firing.aux = 1;        SETS.navigation.aux = 1;        emgsettings ('get aux settings');        emgplot;            case 'open annotation'        if ~dirty_check; return; end;        emgcompare ('compare', 0);        emgvault ('swap', 0);        [status, Ann, filename] = emgafile ('load', 'annotation');        if ~status; return; end;        emgunit ('import', Ann, filename);        emgunit ('reaverage');        SETS.closeup.style='empty';        CURR.unit = 0;        CURR.swap = 0;        CURR.compare = 0;        emgsettings ('show all templates');        emgplot;    case 'save'        if emgafile ('save');            emgplot ('info');        end;    case 'save as ...'        if emgafile ('save as');            emgplot ('info');        end;            case 'preferences';        s = emgprefs ('dialog');        switch s            case 'resize'                emgplot ('busy');                emgunit ('resize');                if isempty(DECOMP.closeup);                    SETS.closeup.style = 'empty';                end;                emgcursors ('timebase', 'closeup', '?');                emgplot;            case 'rebuffer';                emgsignal ('connect', CURR.chan, 1);                emgsignal ('connect', CURR.auxchan, 2);                emgcursors ('timebase', 'navigation', '?');        end;    case 'redraw window';        emgscreen ('resize');    case 'print';        emgprint;        case 'quit';        if ~dirty_check; return; end;        emgprefs ('save');        delete (EMGLAB.figure);        delete (SCREEN.timer);        EMGLAB.figure = [];            case 'copy selected template';         if CURR.unit==0; return; end;        EMGLAB.clipboard.type = 'template';        EMGLAB.clipboard.data = DECOMP.unit(CURR.unit);            case 'copy all templates';        EMGLAB.clipboard.type = 'template';        i = find([DECOMP.unit(:).visible]);        EMGLAB.clipboard.data = DECOMP.unit(i);            case 'copy selected firing pattern';        if CURR.unit==0; return; end;        EMGLAB.clipboard.type = 'slist';        if DECOMP.unit(CURR.unit).virtual;            s = DECOMP.compare_slist;            EMGLAB.clipboard.data = s(s(:,2)==CURR.unit,1);        else            EMGLAB.clipboard.data = emgslist(CURR.unit);        end;            case 'copy all firing patterns';         EMGLAB.clipboard.type = 'slist';        s = emgslist;        p = 1;        for i=1:DECOMP.nunits;            if DECOMP.unit(i).visible;                s(s(:,2)==i,2)=p;                p = p+1;            else                s(s(:,2)==i,:)=[];            end;        end;        EMGLAB.clipboard.data = s;            case 'paste'        if isempty (EMGLAB.clipboard); return; end;        emgvault ('remember', opt);        switch EMGLAB.clipboard.type;            case 'template'                emgunit ('paste',  EMGLAB.clipboard.data);            case 'slist'                emgunit ('create', EMGLAB.clipboard.data);        end;        DECOMP.dirty = 1;        emgsettings ('show all templates');        emgcompare ('synch');        emgplot ({'signal', 'templates', 'firing', 'navigation'});    case 'select channel';        emgvault ('channel', p1);        emgsignal ('filter');        emgunit ('filter');        emgcursors ('timebase', 'closeup', '?', 'no_plot');        emgplot;            case 'select filter'		CURR.band = p1;        emgsignal ('filter');		emgunit ('filter');		DECOMP.closeup = emgsnapshot ('filter', DECOMP.closeup);        emgcursors ('timebase', 'closeup', '?', 'no_plot');		emgplot ({'navigation', 'signal', 'templates', 'closeup'});    case 'auto decomp';        if isempty (EMG.data); return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        SETS.firing.style = 'normal';        emgplot ('firing'); drawnow;        autodecomp;        emgplot;        return;            case 're-average all'        if DECOMP.nunits==0; return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        emgunit ('reaverage');        emgplot ({'signal annotation', 'templates', 'closeup', 'navigation firing'});     case 'center all'        if DECOMP.nunits==0; return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        d = emgunit ('center');        for i=1:length(d);        	DECOMP.closeup = emgsnapshot ('shift', DECOMP.closeup, i, d(i));        end;        emgplot ({'signal annotation', 'templates', 'closeup', 'navigation firing'});    case 'show all'        if DECOMP.nunits == 0; return; end;        emgvault ('remember', opt);		for i=1:DECOMP.nunits;			DECOMP.unit(i).visible = 1;		end;        emgplot ({'signal annotation', 'template colors', 'firing colors', ...            'closeup'})    case 'delete firings'        if DECOMP.nunits==0; return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        [t0, t1] = whattime (SETS.firing);        emgslist ('delete', t0, t1);        emgplot ({'signal', 'firing', 'navigation firing', 'template cascade'});    case 'delete all'        if DECOMP.nunits==0; return; end;        emgvault ('remember', opt);        stat = questdlg ('Are you sure you want to delete the entire decompositon?', 'EMGlab');        if ~strcmp(stat, 'Yes');  return; end;        emgstatus ('init annotation');        emgplot;    case 're-average'        if DECOMP.nunits==0; return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        emgunit ('reaverage', p1);        emgplot ({'signal annotation', 'templates', 'closeup', 'navigation firing'});            case 'center'        if DECOMP.nunits==0; return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        d = emgunit ('center', p1);        DECOMP.closeup = emgsnapshot ('shift', DECOMP.closeup, p1, d(p1));        emgplot ({'signal annotation', 'templates', 'closeup', 'navigation firing'});            case 'hide'        if p1<0 | p1>DECOMP.nunits; return; end;        emgvault ('remember', opt);        DECOMP.unit(p1).visible = ~DECOMP.unit(p1).visible;        emgplot ({'template colors', 'firing colors', 'signal annotation',  ...            'closeup', 'navigation firing'})    case 'export'        emgexport ('create', p1);            case '   templates'        SETS.template.style = 'normal';        emgplot ('templates');            case '   cascade'        SETS.template.style = 'cascade';        emgplot ('templates');            case '   shimmer'        SETS.template.style = 'shimmer';        emgplot ('templates');            case '   signal navigation'        SETS.navigation.style = 'signal';        emgplot ('navigation');            case '   residual navigation'        SETS.navigation.style = 'residual';        emgplot ('navigation');            case '   grid signal'        SETS.signal.grid = ~SETS.signal.grid;        emgplot ('signal');    case '   grid firing'                SETS.firing.grid = ~SETS.firing.grid;        emgplot ('firing');            case '   gird closeup'        SETS.closeup.grid = ~SETS.closeup.grid;        emgplot ('closeup');            case '   show auxiliary signal'        SETS.signal.aux = ~SETS.signal.aux;        emgplot ('signal');            case '   show auxiliary firing'        SETS.firing.aux = ~SETS.firing.aux;        emgplot ('firing');            case '   show auxiliary navigation'        SETS.navigation.aux = ~SETS.navigation.aux;        emgplot ('navigation');            case 'compare annotation with ...'        [status, Ann, filename] = emgafile ('load', 'compare');        if ~status;            return;        end;        emgcompare ('load', Ann, filename);        CURR.swap = 0;        CURR.compare = 1;        emgplot    case 'highlight differences'        emgcompare ('compare', ~CURR.compare);        emgplot ('info');        drawnow;        emgsettings ('show all templates');        emgplot ({'firing', 'templates', 'signal', 'navigation firing', 'closeup'});            case 'swap annotations'        emgvault ('swap', ~CURR.swap);        emgplot ('info');        drawnow;        emgsettings ('show all templates');        emgplot ({'firing', 'templates', 'signal', 'navigation firing', 'closeup'});            case 'select auxiliary'        c = sscanf (p1, '%i');        if CURR.auxchan == 0;            SETS.signal.aux = 1;            SETS.firing.aux = 1;            SETS.navigation.aux = 1;        end;        if c==CURR.auxchan;            emgsettings ('save aux settings');            CURR.auxchan = 0;        else            CURR.auxchan = c;            emgsignal ('connect', c, 2);            emgsettings ('get aux settings');        end;        emgplot;                            case '   settings'        emgsettings ('aux dialog');        emgsettings ('save aux settings');        emgplot ({'signal', 'firing', 'navigation'});        return;                   case 'create unit'        emgvault ('remember', opt);        DECOMP.dirty = 1;        emgunit ('create', p1);         emgsettings ('show all templates');        emgcompare ('synch');        emgplot ({'signal', 'templates', 'firing', 'navigation firing'});    case 'shift template'        if p1<0 | p1>DECOMP.nunits; return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        emgunit  ('shift', p1, p2);        DECOMP.closeup = emgsnapshot ('shift', DECOMP.closeup, p1, p2);        emgplot ({'templates', 'signal annotation', 'firing patterns', 'closeup', 'navigation'});    case 'identify spike'; %p1 = unit, p2 = time;        if p1<0 | p1 > DECOMP.nunits; return; end;        if DECOMP.nunits ==0; return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        ss = emgsnapshot ('snap', p2);        if p1>0;            ss = emgsnapshot ('add unit', ss, p1);        else            ss = emgsnapshot ('add best unit', ss);        end;        ss = emgsnapshot ('align', ss);        emgsnapshot ('update slist', ss);        emgplot ({'signal annotation', 'firing patterns', ...            'navigation firing', 'template cascade'});    case 'delete spike'; 	% p1 = unit, p2 = time        if p1<0 | p1>DECOMP.nunits; return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        t = emgslist ('find', p1, p2);        if abs(t-p2) < 0.025;            emgslist ('delete', t);            emgplot ({'signal annotation', 'firing patterns', ...                'navigation firing', 'template cascade'});        end;    case 'show closeup';         if isempty(EMG.data); return; end;        emgvault ('remember', opt);        emgsettings ('set closeup style', 'normal');        DECOMP.closeup = emgsnapshot ('snap', p1);        emgcursors ('focus', 'closeup', 'z', p1);        case 'add unit to closeup';        if isempty(DECOMP.closeup); return; end;        if ~strcmp(SETS.closeup.style, 'normal');  return; end;        if p1<0 | p1>DECOMP.nunits; return; end;        emgvault ('remember', opt);        if nargin==2;            DECOMP.closeup = emgsnapshot ('add unit', DECOMP.closeup, p1);            DECOMP.closeup = emgsnapshot ('align', DECOMP.closeup);        else            DECOMP.closeup = emgsnapshot ('add unit', DECOMP.closeup, p1, p2);        end;        emgplot ('closeup signals');    case 'resolve closeup';        if isempty(DECOMP.closeup); return; end;        if isempty(DECOMP.closeup.comp); return; end;        if ~strcmp(SETS.closeup.style, 'normal');  return; end;        emgvault ('remember', opt);        DECOMP.closeup = emgsnapshot ('resolve', DECOMP.closeup);        emgplot ('closeup signals');    case 'accept closeup';        if isempty(DECOMP.closeup); return; end;        if ~strcmp(SETS.closeup.style, 'normal');  return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        emgsnapshot ('update slist', DECOMP.closeup);        emgplot ({'signal annotation', 'firing patterns', ...            'navigation firing', 'template cascade'});    case 'adjust closeup';         if isempty(DECOMP.closeup); return; end;        emgvault ('remember', opt, 1);        if nargin==3;            DECOMP.closeup.comp(p1).time = p2;        end;     	DECOMP.closeup = emgsnapshot ('align', DECOMP.closeup);        emgplot ('closeup signals');    case 'delete closeup unit'; % p1 = unit        if isempty(DECOMP.closeup); return; end;        emgvault ('remember', opt);          DECOMP.closeup = emgsnapshot ('delete component', DECOMP.closeup, p1);        emgplot ('closeup signals');    case 'show/hide closeup unit'; % p1 = unit;        if isempty(DECOMP.closeup); return; end;        emgvault ('remember', opt);        DECOMP.closeup = emgsnapshot ('show/hide', DECOMP.closeup, p1);        emgplot ('closeup signals');    case 'merge units'        if strcmp (SETS.closeup.style, 'merge'); return; end;        if p1<0 | p1>DECOMP.nunits;  return; end;        if p2<0 | p2>DECOMP.nunits; return; end;        emgvault ('remember', opt);        SETS.closeup.style = 'merge';        CURR.unit = p2;        ss = emgsnapshot ('unit', p2);        SETS.closeup.time = ss.t0;        DECOMP.closeup = emgsnapshot ('add unit', ss, p1);        emgplot ({'template colors', 'firing', 'signal cursor', 'signal annotation', 'closeup'});    case 'accept merge'        if ~strcmp (SETS.closeup.style, 'merge'); return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        u1 = DECOMP.closeup.unit;        u2 = DECOMP.closeup.comp(1).unit;        d = DECOMP.closeup.comp(1).time;        emgunit ('merge', u1, u2, -d);        if u2<u1;            u1 = u1 - 1;        end;        emgunit  ('reaverage', u1);        SETS.closeup.style = 'empty';        CURR.unit = u1;        emgstatus ('new unit');        emgplot ({'signal annotation', 'templates', 'firing', 'closeup', 'navigation'});    case 'delete unit';        if p1 < 0 | p1 > DECOMP.nunits; return; end;        if DECOMP.unit(p1).virtual;            msgbox ({'This unit is not part of the current annotation.', ...            'You must swap annotations in order to delete it.'}, 'Not a unit');            return;        end;        stat = questdlg ('Are you sure you want to delete this unit?', 'EMGlab');        if ~strcmp(stat, 'Yes');  return; end;        emgvault ('remember', opt);        DECOMP.dirty = 1;        if CURR.unit==p1;            CURR.unit = 0;        elseif CURR.unit > p1;            CURR.unit = CURR.unit - 1;        end;        emgunit ('delete', p1);        DECOMP.closeup = emgsnapshot ('delete unit', DECOMP.closeup, p1);        emgstatus ('new unit');        emgplot ({'signal', 'templates', 'firing patterns', 'closeup', 'navigation'});    case 'reorder units';        emgvault ('remember', opt);        DECOMP.dirty = 1;        if p2==p1;  return; end;        n = DECOMP.nunits;        if p1<1 | p1>n | p2<1 ; return; end;        p2 = min (p2, n);        if p1>p2;            new_order = [1:p2-1, p1, p2:p1-1, p1+1:n];        else            new_order = [1:p1-1, p1+1:p2, p1, p2+1:n];        end;        emgunit ('reorder', new_order);        DECOMP.closeup = emgsnapshot ('reorder', DECOMP.closeup, new_order);        if CURR.unit>0;            CURR.unit = find(new_order==CURR.unit);        end;        emgstatus ('new unit');        emgplot ({'signal', 'templates', 'firing patterns', 'closeup'});            case {'signal panel', 'template panel', 'firing panel', ...            'close-up panel', 'navigation panel'};        emgscreenshot (opt);            otherwise        opt = lower(opt(1:4));    if strcmp (opt, 'undo');        emgvault ('undo');        emgplot;    elseif strcmp (opt, 'redo');        emgvault ('redo');        emgplot;     end;    end;function status = dirty_checkglobal VAULT EMG CURR DECOMP    d = 0;    if size(VAULT.chan,2)>1;    for i=1:EMG.nchannels;        d = d | VAULT.chan(i,2).decomp.dirty;    end;    if d;        r = questdlg ({'Save changes to comparison annotation?', ...            ' ', ...            'The comparison annotation has been changed', ...            'These changes will not be saved automatically.' ...            'If you want to save them, you must return to EMGlab and save them yourself.'}, ...            'EMGlab', 'Don''t save', 'Cancel', 'Let me save them', 'Let me save them');        if ~strcmp (r, 'Don''t save');            status = 0;            return;        end;    end;    end;% notes:  annotationfile 'save' writes over .ann file names    d = DECOMP.dirty;    for i=1:EMG.nchannels;        d = d | VAULT.chan(i,1).decomp.dirty;    end;    if ~d;        status = 1;        return;    end;    emgscreen ('center');        r = questdlg ('Save annotation?', 'EMGlab', ...        'Don''t save', 'Cancel', 'Save', 'Save');    switch r        case 'Don''t save'            status = 1;            return;        case 'Cancel'            status = 0;            return;    end;        currchan = CURR.chan;    currswap = CURR.swap;    achan = 0;    status = 1;            % Save channels associated with .ann files        for i=1:EMG.nchannels;        decomp = VAULT.chan(i,1).decomp;        if ~isempty(decomp.file);            [b, file, ext] = fileparts (decomp.file);        else            ext = ' ';        end;        switch ext            case '.eaf'                achan = i;            case '.ann'                if decomp.dirty;                    emgvault ('channel', i);                    emgvault ('swap', 0);                    %ZDT 05/28/09                     %annotationfile ('save');                    emgafile('save');                end;        end;    end;        % Save all channels to .eaf file if one is open        if achan > 0;        emgvault ('channel', achan);        emgvault ('swap', 0);        %ZDT 05/28/09         %annotationfile ('save')          emgafile('save');        % Otherwise let user save each channel individually        else        emgvault ('channel', currchan);        emgvault ('swap', 0);%         if DECOMP.dirty;%             %ZDT 05/28/09 %             %if ~annotationfile ('save');%             if ~emgafile('save');%                 status = 0;%              end;%         end;        for i = 1:EMG.nchannels;            if VAULT.chan(i,1).decomp.dirty;                emgvault ('channel', i);                emgvault ('swap', 0);                emgplot;                drawnow;                %ZDT 05/28/09                 %if ~annotationfile ('save');                if ~emgafile('save');                    status = 0;                end;            end;        end;    end;         if CURR.chan~=currchan | CURR.swap~=currswap;        emgvault ('channel', currchan);        emgvault ('swap', currswap);        emgplot;    end;    return;        % Save Comparison channels associated with .ann files        achan = 0;    for i=1:EMG.nchannels;        decomp = VAULT.chan(i,1).decomp;        if ~isempty(decomp.file);            [b, file, ext] = fileparts (decomp.file);        else            ext = [];        end;        switch ext            case '.eaf'                if ~decomp.readonly                    achan = i;                end;            case '.ann'                if decomp.dirty & ~decomp.readonly;                    emgvault ('channel', i);                    emgvault ('swap', 1);                    %ZDT 05/28/09                     %annotationfile ('save');                    emgafile('save');                end;        end;    end;        % Save all Comparison channels to .eaf file if one is open        if achan > 0;        emgvault ('channel', achan);        emgvault ('swap', 1);        %ZDT 05/28/09         %annotationfile ('save')           emgafile('save');        % Otherwise let user save each Comparison channel individually        else        emgvault ('channel', currchan);        emgvault ('swap', 1);        emgplot;        drawnow;        if DECOMP.dirty;            %ZDT 05/28/09             %if ~annotationfile ('save');             if ~emgafile('save');                status = 0;            end;        end;        for i = 1:EMG.nchannels;            if VAULT.chan(i,1).decomp.dirty;                emgvault ('channel', i);                emgvault ('swap', 1);                emgplot;                drawnow;                %ZDT 05/28/09                 %if ~annotationfile ('save');                 if ~emgafile('save');                    status = 0;                end;            end;        end;    end;        if CURR.chan~=currchan | CURR.swap~=currswap;        emgvault ('channel', currchan);        emgvault ('swap', currswap);        emgplot;    end;                                   