function f = emgscreen (opt, p1, p2)% EMGlab function for Creating and managing the EMGlab window.% This function creates all axes and uicontrols.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	global SETS SCREEN EMGLAB    switch lower(opt)			% New figure		case 'new';        		default_screen_width 	= 1200;		default_screen_height 	= 700;		font_size 				= emgprefs('font_size');				figure_position = emgprefs('figure_position');		if figure_position == 0 | length(figure_position)~=4;			temp = get (0, 'units');			set (0, 'units', 'pixels');			screensize = get (0, 'screensize');			set (0, 'units', temp);					screen_width = screensize (3);			screen_height = screensize (4);					figure_width = min (default_screen_width, screen_width - 10);			figure_height = min (default_screen_height, screen_height - 100);					figure_bottom = ceil (screen_height - figure_height - 50);			figure_left = ceil ((screen_width - figure_width) / 2);			figure_position = [figure_left, figure_bottom, figure_width, figure_height];		end;        				f = figure ( ...            'Name','EMGlab',...            'NumberTitle','off',...			'integerhandle', 'off', ...			'menubar', 'none', ...			'tag', 'EMGLAB', ...			'units', 'pix', ...			'color', SETS.colors.background, ...			'pos', figure_position, ...			'defaultuicontrolunits', 'pix', ...            'windowbuttondown', 'emgevent(''mousedown'');', ...			'windowbuttonup', 'emgevent(''mouseup'');', ...            'keypressfcn', @keyPress,...            'Renderer','painters', ...            'doublebuffer', 'on', ...            'backingstore', 'on', ...            'PaperPositionMode','auto',...            'PaperOrientation','landscape',...			'defaultuicontrolfontsize', font_size, ...			'defaultuimenucallback', 'emgevent(''menucallback'');', ...			'closerequest', 'emgaction(''Quit'');', ...			'defaultaxesbox', 'on', ...			'defaultaxesunits', 'pixels', ...			'defaultaxesxtick', [], ...			'defaultaxesytick', [], ...			'defaultuicontrolback', SETS.colors.menu, ...            'defaultuicontrolcallback', 'emgevent(''buttonpress'');', ...			'defaultuicontrolstyle', 'push', ...			'defaultlineerase', 'back', ...			'defaultlinevisible', 'off', ...			'defaulttexterase', 'back', ...			'defaulttextvisible', 'off', ...            'defaultpatchhittest', 'off', ...            'defaultpatchvisible', 'off', ...            'defaultpatchedgecolor', 'none', ...			'defaultaxesnext', 'add', ...            'defaulttextfontsize', 10, ...			'defaulttextclipping', 'on', ...            'interruptible', 'off', ...            'busyaction', 'cancel');                %adds  scrollWheel capability to EMGlab        if EMGLAB.matlab_version>7.3            set(f,'WindowScrollWheelFcn',@scrollWheel);        end                if EMGLAB.matlab_version > 7            set (f, 'defaultuicontrolkeypressfcn', @keyPress);        end;  	        SCREEN.figure = f;        emgmenu (f);        emgplugin ('menu', f);        drawnow;	% sets menubar color			           SCREEN.layout = struct (...                'MAP_height', 16,...                'NAV_height', 40, ...                'SIG_height', 150, ...                'TMP_height', 100, ...                'CLO_height', 250, ...                'FIR_width', 100, ...                'CLO_width', 100, ...                'SIG_width', 100, ...                'figure_position', figure_position);        SCREEN.down_click = [];        SCREEN.timer = timer ('Period', 0.05, 'executionmode', 'fixedspacing', 'busymode', 'drop');        SCREEN.play = struct ('running', 0, 'audio', 0, 'player', []);        		emgscreen ('resize');		set (f,	'handlevisibility', 'callback',...            'windowbuttonmotionfcn', 'emgevent(''mousemotion'');');    	        if EMGLAB.matlab_version ~= 7.1 % resizefcn doesn't work in v7.1			set (f, 'resizefcn', 'emgscreen(''resizecall'');');                    end;				return;						% Resize callback    case 'resizecall'   % This is a work around for an apparent bug in matlab 7.0.1 for mac        delete (findobj(SCREEN.figure, 'type', 'axes'));		delete (findobj(SCREEN.figure, 'type', 'uicontrol'));        drawnow;        emgscreen ('resize');		return;			% Change layout		case 'change layout'		if nargin > 1;			SCREEN.layout = p1;		end;%		set (SCREEN.figure, 'position', SCREEN.layout.figure_position);		SCREEN.layout.figure_position = get (SCREEN.figure, 'position');		emgscreen ('resize');            % Center        case 'center'        figPos = get(SCREEN.figure,'pos');        screen = get(0,'ScreenSize');        screenWidth = screen(3);        screenHeight = screen(4);        %checks if the figure is off the screen        %if it is it draws it in the center of the screen        if figPos(1) < -figPos(3)/3 | figPos(2) < - figPos(4)/3 ...            | screenWidth-figPos(1) < figPos(3)*2/3;            newPos = [(screenWidth-figPos(3))/2, ...                (screenHeight-figPos(4))/2, figPos(3),figPos(4)];            set (SCREEN.figure, 'pos', newPos);        end;        return;            otherwise        if nargin<2; p1 = []; end;        if nargin<3; p2 = []; end;        emgscreen2 (opt, p1, p2);    end;% Other Options:     function emgscreen2 (opt, p1, p2)    global SETS SCREEN EMGLAB CURR   	% Set parameters    	top_margin				=  10;	bottom_margin 			=  20;	left_margin 			=  10;	right_margin 			=  10;	large_gap	 			=   9;	small_gap				=   0;	layout = SCREEN.layout;	set (SCREEN.figure, 'defaultuicontrolfontsize', emgprefs('font_size'));	t = uicontrol(SCREEN.figure, 'style', 'text', 'string', 'X', 'vis', 'off');	e = get(t,'extent');	character_size = e(4);	delete (t);	    button_width = character_size;    bw = button_width;    button_height = character_size;    popup_width = 6*character_size;    minimum_SIG_height = 4*button_height + 3*small_gap;    minimum_TMP_height = 3*button_height + 2*small_gap;    minimum_CLO_height = 4*button_height + 3*small_gap;    minimum_plot_width = 2*popup_width + small_gap + 2*(button_width + small_gap);    layout.figure_position = get(SCREEN.figure,'pos');    figure_width = layout.figure_position(3);    figure_height = layout.figure_position(4);        if EMGLAB.matlab_version <= 6;        popup_correction = [0,0,0,0];        axes_correction  = [0,0,0,0];    else        popup_correction = [0,4,0,0];        axes_correction  = [0,1,-1,-1];    end    	C = SETS.colors;		switch lower(opt)		% Resize window		case 'resize'		layout.NAV_height = max(2*button_height + small_gap, 40);		fixed_vspace = top_margin + bottom_margin + 4*large_gap + button_height + small_gap ...            + layout.MAP_height + layout.NAV_height;		available_vspace = figure_height - fixed_vspace;		f = layout.SIG_height + layout.TMP_height + layout.CLO_height;		if layout.SIG_height > 0;			layout.SIG_height = max (floor(available_vspace * layout.SIG_height / f), minimum_SIG_height);		end;		if layout.TMP_height > 0;			layout.TMP_height = max (floor(available_vspace * layout.TMP_height / f), minimum_TMP_height);		end;		if layout.CLO_height > 0;			layout.CLO_height = max (available_vspace  - layout.SIG_height - layout.TMP_height, ...				minimum_CLO_height);		end;		total_height = fixed_vspace + layout.SIG_height + layout.TMP_height + layout.CLO_height;			fixed_hspace = left_margin + right_margin + large_gap;		available_hspace = figure_width - fixed_hspace;		f = layout.FIR_width + layout.CLO_width;		if layout.FIR_width > 0;			layout.FIR_width = max (floor(available_hspace * layout.FIR_width / f), minimum_plot_width);		end;		if layout.CLO_width > 0;			layout.CLO_width = max (available_hspace - layout.FIR_width, minimum_plot_width);		end;		layout.SIG_width = layout.FIR_width + layout.CLO_width + large_gap;		total_width = fixed_hspace + layout.FIR_width + layout.CLO_width;		SCREEN.layout = layout;		if figure_width < total_width | figure_height < total_height;			figure_width = max (figure_width, total_width);			figure_height = max (figure_height, total_height);			p = layout.figure_position;			set (SCREEN.figure, 'pos', [p(1), p(2) + p(4) - figure_height, figure_width, figure_height]);   %         emgscreen ('draw'); %%%%%%%			% invokes resizefcn	%		return;		end;		emgscreen ('draw');			% Adjust panel sizes			case 'adjust'		p2 = round(p2);		change = abs(p2);        if change < 2; return; end;                		switch p1;				case 'SIG'   			available = layout.SIG_height + layout.TMP_height;			total = available + layout.CLO_height;         			if p2 < 0 & change < layout.SIG_height;				layout.SIG_height = max(layout.SIG_height - change, minimum_SIG_height) ;				layout.TMP_height = available - layout.SIG_height;			elseif p2 < 0;            				layout.SIG_height = 0;				layout.TMP_height = available;			elseif change < layout.TMP_height;				layout.TMP_height = max(layout.TMP_height - change, minimum_TMP_height);				layout.SIG_height = available - layout.TMP_height;			elseif change < layout.TMP_height + large_gap + layout.CLO_height				layout.CLO_height = max(layout.CLO_height - (change - layout.TMP_height), minimum_CLO_height);				layout.TMP_height = 0;				layout.SIG_height = total - layout.CLO_height;			else				layout.TMP_height = 0;				layout.CLO_height = 0;				layout.SIG_height = total;			end;						case 'TMP'            available = layout.TMP_height + layout.CLO_height;			total = available + layout.SIG_height;                        if p2 < 0 & change < layout.TMP_height;				layout.TMP_height = max(layout.TMP_height - change, minimum_TMP_height) ;				layout.CLO_height = available - layout.TMP_height;			elseif p2 < 0 & change < layout.TMP_height + large_gap + layout.SIG_height;				layout.SIG_height = max(layout.SIG_height - (change - layout.TMP_height), minimum_SIG_height);				layout.TMP_height = 0;				layout.CLO_height = total - layout.SIG_height;			elseif p2 < 0;				layout.TMP_height = 0;				layout.SIG_height = 0;				layout.CLO_height = total;			elseif p2 < layout.CLO_height				layout.CLO_height = max(layout.CLO_height - change, minimum_CLO_height);				layout.TMP_height = available - layout.CLO_height;			else				layout.CLO_height = 0;				layout.TMP_height = available;            end;				case 'FIR'			available = layout.FIR_width + layout.CLO_width;			if p2 < 0 & change < layout.FIR_width;				layout.FIR_width = max(layout.FIR_width - change, minimum_plot_width);				layout.CLO_width = available - layout.FIR_width;			elseif p2 < 0				layout.FIR_width = 0;				layout.CLO_width = available;			elseif change < layout.CLO_width;				layout.CLO_width = max(layout.CLO_width - change, minimum_plot_width) ;				layout.FIR_width = available - layout.CLO_width;							else				layout.CLO_width = 0;				layout.FIR_width = available;			end;				end;			SCREEN.layout = layout;		emgscreen ('draw');				% Draw	case 'draw'        fig = SCREEN.figure;        figure (fig);		delete (findobj(fig, 'type', 'axes'));		delete (findobj(fig, 'type', 'uicontrol'));        delete (findobj(fig, 'type', 'uipanel'));        SCREEN.region = struct('type', {}, 'id', {});        SCREEN.region_position = [];        SCREEN.down_click = [];		set (fig, 'color', C.background, ...            'defaultaxesxcolor',        C.background, ...            'defaultaxesycolor',        C.background, ...			'defaultuicontrolback', 	C.button, ...			'defaultuicontrolfore', 	C.button_text, ...			'defaultaxescolor',			C.panel, ...            'defaultaxesvis',           'on', ...            'pointer',                  'arrow');                switch CURR.draw_mode                        case 'smoother'                set (fig, 'defaultlineerase',   'norm', ...                        'defaulttexterase',     'norm', ...                        'defaultpatcherase',    'norm');             otherwise                               set (fig, 'defaultlineerase',   'none', ...                        'defaulttexterase',     'none', ...                        'defaultpatcherase',    'none');         end;        if EMGLAB.matlab_version >= 7 & strcmp (computer, 'MAC');        	popparent = uipanel ('units', 'pixels', 'pos', [1, 1, figure_width, figure_height'], ...                'back', C.background, 'bordertype', 'none');        else			popparent = fig;        end;				% Main guide lines        	        MAP_base = bottom_margin + 1;        NAV_base = MAP_base + layout.MAP_height + large_gap;		CLO_base = NAV_base + layout.NAV_height + large_gap;		TMP_base = CLO_base + layout.CLO_height + large_gap;		SIG_base = TMP_base + layout.TMP_height + large_gap;		SIG_edge = 1 + left_margin;		CLO_edge = SIG_edge + layout.FIR_width + large_gap;            % Info Line                plot_width = layout.SIG_width - 2*(button_width + small_gap);		x0 = SIG_edge; 		x1 = SIG_edge + button_width + small_gap;   % Channel        x2 = x1 + popup_width + small_gap;          % Filter		x2a= x2 + popup_width + large_gap + small_gap;  % Signal filename		x3 = x1 + plot_width - popup_width;     % Sensitivity        if x3-x2a > 5*popup_width + 2*large_gap + 2*small_gap;            x2b = x2a + 2*popup_width + large_gap + small_gap;  % Annotation filename            w2 = popup_width;        else            w2 = floor ((x3 - x2a - 2*large_gap - 2*small_gap) / 5);            x2b = x2a + 2*w2 + large_gap + small_gap;        end;        w2b = x3 - x2b - large_gap - small_gap;                y4 = figure_height - top_margin - button_height;        y4 = SIG_base + layout.SIG_height + small_gap;                tabx = [x0, x2a, x2a+4, x2a+popup_width-4, x2a+popup_width, SIG_edge+layout.SIG_width, x0];        taby = [y4, y4, y4+button_height, y4+button_height, y4, y4, y4];         		  		SCREEN.info.channel = uicontrol ('style', 'popup', 'tag', 'channel', 'string', ' ', ...            'parent', popparent, ... 			'pos', [x1, y4, popup_width, button_height] + popup_correction, ... 			'back', C.popup, 'fore', C.popup_text); 		SCREEN.info.filter = uicontrol ('style', 'popup', 'tag', 'filter', 'string', ' ', ...            'parent', popparent, ... 			'pos', [x2, y4, popup_width, button_height] + popup_correction, ... 			'back', C.popup, 'fore', C.popup_text);                SCREEN.info.filename = uicontrol ('style', 'text', 'tag', 'emg file name', 'string', ' ', ... 			'pos', [x2a, y4, 2*w2, button_height], ...    		'hor', 'l', 'back', C.background, 'fore', C.backgr_text);          SCREEN.info.annotation(1) = uicontrol ('style', 'text', 'tag', 'compare file', ...           'string', 'Annotation: ', 'horiz', 'l',  ...           'pos', [x2b, y4, w2b, button_height], ...           'back', C.background, 'fore', C.backgr_text);              SCREEN.info.annotation(2) = uicontrol ('style', 'text', 'tag', 'compare file', ...           'string', ' ', 'horiz', 'l',  ...           'pos', [x2b, y4, w2b, button_height], ...           'back', C.background, 'fore', C.backgr_text);               SCREEN.info.annotation(3) = uicontrol ('style', 'text', 'tag', 'compare file', ...           'string', ' ', 'horiz', 'l',  ...           'pos', [x2b, y4, w2b, button_height], ...           'back', C.background, 'fore', C.backgr_text);      		SCREEN.info.emgsens = uicontrol ('style', 'text', 'tag', 'emg sens', 'string', ' ', ... 			'pos', [x3, y4, popup_width, button_height], ... 			'hor', 'r', 'back', C.background, 'fore', C.graticule);        		emgsettings ('set popups');    % Map Panel              plot_edge = SIG_edge  + button_width + small_gap;        plot_width = layout.SIG_width - 2*(button_width + small_gap);        c1 = .5*C.background + .5*C.button;        c2 = .5*C.panel + .5*C.button;        if norm(c1-C.button) > norm(c2-C.button);            c = c1;        else            c = c2;        end;        SCREEN.map.axes = axes ('parent', fig, 'tag', 'map', ...			'pos', [plot_edge,MAP_base, plot_width, layout.MAP_height] + axes_correction, ...            'color', c, ...            'xlim', [0,10], 'ylim', [0,1]);        SCREEN.map.box = patch ([0;10;10;0;0], [0;0;1;1;0], c, ...            'edgecolor', .5*C.panel+.5*c, 'tag', 'box', 'vis', 'on'); 		SCREEN.map.cursor(1) = patch (0, 0, C.button, 'edgecolor', .7*C.signal + .3*c, 'tag', 'mapcursor', ...            'vis', 'off');        SCREEN.map.text = text (0, 0, ' ', 'color', C.panel_text); 		SCREEN.map.cursor(2) = patch (0, 0, C.button, 'edgecolor', .7*C.signal + .3*c, 'tag', 'mapcursor', ...            'vis', 'off', 'erase', 'back');        x0 = SIG_edge;		x1 = SIG_edge + button_width + plot_width + 2*small_gap;        y0 = MAP_base;        set (fig, 'defaultuicontroltag', 'map');           h = layout.MAP_height;        uicontrol ('pos', [x0, y0, bw, h], 'string', '<<', 'tool', 'rewind');        uicontrol ('pos', [x1, y0, bw, h], 'string', 'P', 'tool', 'play/stop');  				% Navigation Panel                		SCREEN.navigation.axes = axes ('parent', fig, 'tag', 'navigation', ...			'pos', [plot_edge, NAV_base, plot_width, layout.NAV_height] + axes_correction, ...            'xlim', [0,10], 'ylim', [-1,1]);        SCREEN.navigation.box = patch ([0;10;10;0;0], [-1;-1;1;1;-1], C.panel, ...            'edgecolor', C.panel_edge, 'vis', 'on');		SCREEN.navigation.fcursor(1) = patch (nan, nan, C.cursor); 		SCREEN.navigation.scursor(1) = patch (nan, nan, C.cursor);		SCREEN.navigation.ccursor(1) = patch (nan, nan, C.cursor);        SCREEN.navigation.frame    = line ([0;10;10;0;0], [-1;-1;1;1;-1], 'color', C.panel_edge, 'vis', 'on'); 		SCREEN.navigation.grat     = line (nan*zeros(2,2), nan*zeros(2,2), 'color', C.graticule, 'tag', 'graticule'); 		SCREEN.navigation.scale    = text (zeros(20,1), zeros(20,1), ' ', 'col', C.graticule);        SCREEN.navigation.aux      = line (nan, nan, 'color', C.aux);		SCREEN.navigation.signal = line (0, 0, 'color', .7*C.signal + .3*C.panel); %%%%, 'erase', 'none');		SCREEN.navigation.firing = line (zeros(2,4), zeros(2,4), 'color', C.template, 'marker', '.', 'markersize', 1, ...			'linestyle', 'none'); 		SCREEN.navigation.fcursor(2) = patch (nan, nan, C.cursor, 'erase', 'xor'); 		SCREEN.navigation.scursor(2) = patch (nan, nan, C.cursor, 'erase', 'xor'); 		SCREEN.navigation.ccursor(2) = patch (nan, nan, C.cursor, 'erase', 'xor');         set (fig, 'defaultuicontroltag', 'navigation');        		uicontrol ('string', '| |', 'tool', 'zoom in', ...			'pos', [plot_edge - button_width - small_gap, NAV_base, button_width, layout.NAV_height]); 		uicontrol ('string', '|||', 'tool', 'zoom out', ...			'pos', [plot_edge + plot_width + small_gap, NAV_base, button_width, layout.NAV_height]);      	% Signal Panel		if layout.SIG_height > 0;		plot_width = layout.SIG_width - 2*(button_width + small_gap);		plot_height = layout.SIG_height;		x0 = SIG_edge;		x1 = SIG_edge + button_width + small_gap;		x4 = x1 + plot_width + small_gap;		h1 = min (floor ((plot_height - 2*small_gap) / 3), popup_width);		h2 = min (plot_height - 2*(h1 + small_gap), popup_width);			y1 = SIG_base + floor ((plot_height - 2*h1 - h2 - 2*small_gap)/2);		y2 = y1 + h1 + small_gap;		y3 = y2 + h1 + small_gap;		horizontal_division = plot_width / (SETS.signal.right - SETS.signal.left);		vertical_division = plot_height / 2;				SCREEN.signal.axes = axes ('parent', fig, 'tag', 'signal', ...			'pos', [x1, SIG_base, plot_width, plot_height] + axes_correction, ...            'xlim', [0,10], 'ylim', [-1,1]);	        SCREEN.signal.box = patch ([0;10;10;0;0], [-1;-1;1;1;-1], C.panel, ...            'edgecolor', C.panel, 'vis', 'on'); 		SCREEN.signal.cursor(1) = patch (nan, nan, 0.5*C.cursor + 0.5*C.panel);        SCREEN.signal.frame = line ([0;10;10;0;0], [-1;-1;1;1;-1], 'color', C.panel_edge, 'vis', 'on');		SCREEN.signal.grat  = line (nan*zeros(2,2), nan*zeros(2,2), 'color', C.graticule, 'tag', 'graticule');		SCREEN.signal.scale = text (zeros(25,1), zeros(25,1), ' ', 'color', C.graticule, ...				'fontsize', 9, 'tag', 'graticule');        SCREEN.signal.aux    = line (nan, nan, 'color', C.aux,    'tag', 'emg aux');		SCREEN.signal.signal = line (nan, nan, 'color', C.signal, 'tag', 'emg signal');		SCREEN.signal.resid  = line (nan, nan, 'color', C.residual,  'tag', 'resid');		SCREEN.signal.bar    = line (nan, nan, 'color', C.selection, 'tag', 'bar');		SCREEN.signal.text   = text (zeros, zeros, ' ', 'tag', 'text');        SCREEN.signal.cursor(2) = patch (nan, nan, 0.5*C.cursor + 0.5*C.panel, 'erase', 'xor');     	set (fig, 'defaultuicontroltag', 'signal');        		uicontrol ('pos', [x0, y1, bw, h1], 'string', '|||',  'tool', 'zoom out');        mcbutton  ('pos', [x0, y2, bw, h1], 'string', '<',   'tool', 'scroll left');		uicontrol ('pos', [x0, y3, bw, h2], 'string', '| |', 'tool', 'zoom in');		uicontrol ('pos', [x4, y1, bw, h1], 'string', '-',   'tool', 'scale down');		mcbutton  ('pos', [x4, y2, bw, h1], 'string', '>',   'tool', 'scroll right');		uicontrol ('pos', [x4, y3, bw, h2], 'string', '+',   'tool', 'scale up');        else            SCREEN.signal.axes = [];        end;               	% Template Panel				if layout.TMP_height > 0;		plot_width = layout.SIG_width - 3*(button_width + small_gap);		plot_height = layout.TMP_height;		x0 = SIG_edge;        xa = SIG_edge + button_width + small_gap;		x1 = SIG_edge + 2*(button_width + small_gap);		x2 = x1 + plot_width + small_gap;		h1 = min (floor ((plot_height - 2*small_gap) / 3), popup_width);		h2 = min (plot_height - 2*(h1 + small_gap), popup_width);			y1 = TMP_base + floor ((plot_height - 2*h1 - h2 - 2*small_gap)/2);		y2 = y1 + h1 + small_gap;		y3 = y2 + h1 + small_gap;                       sig_height = max (layout.SIG_height, minimum_SIG_height);		SETS.template.top = SETS.signal.top * layout.TMP_height / sig_height;		SETS.template.bottom = SETS.signal.bottom * layout.TMP_height / sig_height;        SETS.template.right = 10*plot_width / (plot_width + button_width + small_gap);        SCREEN.template.axes = axes ('parent', fig, 'tag', 'template', ...			'pos', [x1, TMP_base, plot_width, plot_height] + axes_correction, ...            'xlim', [0,SETS.template.right], 'ylim', [SETS.template.bottom, SETS.template.top]);		b = SETS.template.bottom;        t = SETS.template.top;        SCREEN.template.box = patch ([0;10;10;0;0], [b;b;t;t;b], C.panel, 'edgecolor', C.panel_edge);        SCREEN.template.frame = line ([0;10;10;0;0], [b;b;t;t;b], 'color', C.panel_edge, 'vis', 'on');        SCREEN.template.grat = line (nan*zeros(2,2), nan*zeros(2,2), 'color', .2*C.graticule + .8*C.panel);        SCREEN.template.signal = line (zeros(2,50), zeros(2,50), 'tag', 'signal');        m = uicontextmenu ('parent', SCREEN.figure);		uimenu (m, 'label', 'Re-average');        uimenu (m, 'label', 'Center');		uimenu (m, 'label', 'Hide');        uimenu (m, 'label', 'Export');        uimenu (m, 'label', 'Delete unit', 'separator', 'on');		SCREEN.template.text   = text (zeros(50,1), zeros(50,1), ' ', 'uicontextmenu', m);                set (fig, 'defaultuicontroltag', 'template');		uicontrol ('pos', [x0, y1, bw, h1], 'string', '|||',  'tool', 'show more');		uicontrol ('pos', [x0, y2, bw, h1], 'string', '<',   'tool', 'scroll left');		uicontrol ('pos', [x0, y3, bw, h2], 'string', '| |', 'tool', 'show fewer'); 		uicontrol ('pos', [x2, y1, bw, h1], 'string', '-',   'tool', 'scale down');		uicontrol ('pos', [x2, y2, bw, h1], 'string', '>',   'tool', 'scroll right');		uicontrol ('pos', [x2, y3, bw, h2], 'string', '+',   'tool', 'scale up');                        SCREEN.tempcursor.axes = axes ('parent', fig, 'tag', 'tempcursor', ...            'pos', [xa, TMP_base, bw, plot_height] + axes_correction, ...            'xlim', [0,1], 'ylim', [0,1]);        b = SETS.template.bottom;        SCREEN.tempcursor.box = patch ([0;1;1;0;0], [0,0,1,1,0], C.panel, 'edgecolor', C.panel);        SCREEN.tempcursor.cursor(1) = patch (nan, nan, 0.5*C.template + 0.5*C.panel);        if C.panel==C.background;            SCREEN.tempcursor.frame = line ([1,0,0,1], [0,0,1,1], 'color', C.panel, 'vis', 'off');        else            SCREEN.tempcursor.frame = line ([1,0,0,1], [0,0,1,1], 'color', C.panel_edge, 'vis', 'off');        end;        SCREEN.tempcursor.cursor(2) = patch (nan, nan, 0.5*C.template + 0.5*C.panel, 'erase', 'xor');        else            SCREEN.template.axes = [];            SCREEN.tempcursor.axes = []; 		end;	% Firing panel        SCREEN.firing = [];		if layout.CLO_height > 0 & layout.FIR_width > 0;		plot_width = layout.FIR_width - 2*(button_width + small_gap);		plot_height = layout.CLO_height;		x0 = SIG_edge;		x1 = SIG_edge + button_width + small_gap;		x2 = x1 + plot_width + small_gap;		h1 = min (floor ((plot_height - 3*small_gap) / 4), popup_width);		h2 = min (plot_height - 3*(h1 + small_gap), popup_width);			h3 = h1 + h1 + small_gap;		y1 = CLO_base + floor ((plot_height - 3*h1 - h2 - 3*small_gap)/2);		y2 = y1 + h1 + small_gap;		y3 = y2 + h1 + small_gap;		y4 = y3 + h1 + small_gap;		y5 = CLO_base + plot_height + small_gap;        d = button_width / (plot_width - button_width) * 10;                m = uicontextmenu ('parent', SCREEN.figure);        uimenu (m,'label','Export');        SCREEN.firing.axes = axes ('parent', fig, 'tag', 'firing', ...			'pos', [x1+button_width, CLO_base, plot_width-button_width, plot_height] + axes_correction, ...            'xlim', [0,10], 'ylim', [0,1]);        SCREEN.firing.box = patch ([-d;10;10;-d;-d], [0;0;1;1;0], C.panel, 'edgecolor', C.panel,...            'clipping', 'off');		SCREEN.firing.cursor(1) = patch (nan, nan, 0.5*C.cursor + 0.5*C.panel);        if C.panel==C.background;            SCREEN.firing.frame   = line ([0,10,10,0,0], [0,0,1,1,0], 'color', C.panel_edge, 'vis', 'on');        else            SCREEN.firing.frame   = line ([-d,10,10,-d,-d,0,0], [0,0,1,1,0,0,1], ...                'clipping', 'off', 'color', C.panel_edge, 'vis', 'on');        end;		SCREEN.firing.grat    = line (nan*zeros(2,2), nan*zeros(2,2), 'color', C.graticule, 'tag', 'graticule');		SCREEN.firing.scale   = text (zeros(20,1), zeros(20,1), ' ', 'col', C.graticule, 'tag', 'graticule');		SCREEN.firing.aux     = line (nan, nan, 'color', C.aux);        SCREEN.firing.pattern = line (nan*zeros(2,50), nan*zeros(2,50));		SCREEN.firing.extra   = line (nan, nan, 'color', C.template, 'linestyle', 'none', 'marker', 'o');               		SCREEN.firing.text    = text (zeros(50,1), zeros(50,1), ' ', 'tag', 'firing text', ...            'clipping', 'off', 'uicontextmenu', m);		SCREEN.firing.cursor(2) = patch (nan, nan, 0.5*C.cursor + 0.5*C.panel, 'erase', 'xor');  		set (fig, 'defaultuicontroltag', 'firing');		uicontrol ('pos', [x0, y1, bw, h1], 'string', '|||', 'tool', 'zoom out');		uicontrol ('pos', [x0, y2, bw, h1], 'string', 'o',   'tool', 'change display style');		mcbutton  ('pos', [x0, y3, bw, h1], 'string', '<',   'tool', 'scroll left');		uicontrol ('pos', [x0, y4, bw, h2], 'string', '| |', 'tool', 'zoom in');		uicontrol ('pos', [x2, y1, bw, h1], 'string', '-',   'tool', 'scale down');		uicontrol ('pos', [x2, y2, bw, h1], 'string', ' ',   'tool', 'reserved');		mcbutton  ('pos', [x2, y3, bw, h1], 'string', '>',   'tool', 'scroll right');		uicontrol ('pos', [x2, y4, bw, h2], 'string', '+',   'tool', 'scale up');                x = x2 - popup_width - large_gap - small_gap;        y = CLO_base + plot_height - button_height - large_gap - small_gap;        SCREEN.firing.lowpass = uicontrol ('style', 'popup', 'tag', 'lowpass', 'string', ' ', ...            'parent', popparent, ... 			'pos', [x, y, popup_width, button_height], ... 			'back', C.popup, 'fore', C.popup_text, 'vis', 'off', ...            'string', '0.5 Hz|1 Hz|2 Hz|4 Hz|8 Hz|16 Hz', 'value', 3);%        m = uicontextmenu ('parent', SCREEN.figure);%        uimenu (m, 'label', '0.5 Hz');%        uimenu (m, 'label', '1 Hz');%        uimenu (m, 'label', '2 Hz');%        uimenu (m, 'label', '4 Hz');%        SCREEN.firing.filter = text (9.8, 9.8, '2 Hz', 'col', C.graticule, ...%            'hor', 'r', 'ver', 't', 'uicontextmenu', m);        else            SCREEN.firing.axes = [];		end;	% Closeup panel		if layout.CLO_height > 0 & layout.CLO_width > 0;		plot_width = layout.CLO_width - 2*(button_width + small_gap);		plot_height = layout.CLO_height;		x0 = CLO_edge;		x1 = CLO_edge + button_width + small_gap;		x2 = x1 + plot_width + small_gap;		h1 = min (floor ((plot_height - 3*small_gap) / 4), popup_width);		h2 = min (plot_height - 3*(h1 + small_gap), popup_width);		h3 = h1 + h1 + small_gap;		y1 = CLO_base + floor ((plot_height - 3*h1 - h2 - 3*small_gap)/2);		y2 = y1 + h1 + small_gap;		y3 = y2 + h1 + small_gap;		y4 = y3 + h1 + small_gap;		y5 = CLO_base + plot_height + small_gap;        SCREEN.closeup = [];		SCREEN.closeup.axes = axes ('parent', fig, 'tag', 'closeup', ...			'pos', [x1, CLO_base, plot_width, plot_height] + axes_correction, ...            'xlim', [-2.5,2.5], 'ylim', [-3,1]);	        SCREEN.closeup.box = patch ([-2.5,2.5,2.5,-2.5,-2.5], [-3,-3,1,1,-3], C.panel, ...             'edgecolor', C.panel_edge, 'tag', 'box', 'vis', 'on');        SCREEN.closeup.frame = line ([-2.5,2.5,2.5,-2.5,-2.5], [-3,-3,1,1,-3], 'color', C.panel_edge, ...            'vis', 'on');		SCREEN.closeup.grat   = line (nan*zeros(2,2), nan*zeros(2,2), 'color', C.graticule, 'tag', 'graticule');		SCREEN.closeup.scale  = text (zeros(20,1), zeros(20,1), ' ', 'col', C.graticule, 'tag', 'graticule');			SCREEN.closeup.signal = line (nan, nan, 'color', C.signal);		SCREEN.closeup.recon  = line (nan, nan, 'color', C.reconstruct);		SCREEN.closeup.resid  = line (nan, nan, 'color', C.residual);		SCREEN.closeup.temp   = line (nan*zeros(2,20), nan*zeros(2,20), 'tag', 'unit');		SCREEN.closeup.text   = text (zeros(20,1), zeros(20,1), ' ', 'tag', 'unit'); 		set (fig, 'defaultuicontroltag', 		'closeup');		uicontrol ('pos', [x0, y1, bw, h1], 'string', '|||',  'tool', 'zoom out');		uicontrol ('pos', [x0, y2, bw, h1], 'string', ' ',   'tool', 'reserved');		uicontrol ('pos', [x0, y3, bw, h1], 'string', 'x',   'tool', 'revert');		uicontrol ('pos', [x0, y4, bw, h2], 'string', '| |', 'tool', 'zoom in');		uicontrol ('pos', [x2, y1, bw, h1], 'string', '-',   'tool', 'scale down');		uicontrol ('pos', [x2, y2, bw, h1], 'string', 'OK',  'tool', 'accept', ...			'fontsize', emgprefs('font_size') - 2);		uicontrol ('pos', [x2, y3, bw, h1], 'string', 'R',   'tool', 'resolve');		uicontrol ('pos', [x2, y4, bw, h2], 'string', '+',   'tool', 'scale up');		else            SCREEN.closeup.axes = [];        end;		        % Add panels to list of hot spots                ax_handle = findobj(SCREEN.figure, 'type', 'axes');        for i=1:length(ax_handle);            h = ax_handle(i);            region ('axes', get(h, 'pos'), h);        end;                		% Resize bars                region ('resize bar', [SIG_edge, SIG_base - large_gap, layout.SIG_width, large_gap], 'SIG');        region ('resize bar', [SIG_edge, TMP_base - large_gap, layout.SIG_width, large_gap], 'TMP'); 		if layout.CLO_height > 0;    		region ('resize bar', [CLO_edge-large_gap, CLO_base, large_gap, ...                layout.CLO_height-button_height], 'FIR');		end;                % Sprite axes                SCREEN.sprite.axes = axes ('tag', 'sprite', 'DrawMode','fast', ...             'hittest', 'off', ...            'pos', [0, 0, figure_width, figure_height], 'color', 'none', ...            'xlim', [0, figure_width], 'ylim', [0, figure_height]);        SCREEN.sprite.signal = line (0, 0, 'color', C.selection, 'erase', 'xor');        SCREEN.sprite.text = text (-10, -10, ' ', 'color', 'k', 'back', [255, 255, 193]/255, ...            'edge', 'k');                             		drawnow;  % Prevents glitch in popup color		emgplot;		end;        function mcbutton (varargin)    global CURR EMGLAB    switch CURR.animation;        case {'no auto scroll', 'off'}             uicontrol (varargin{:});        otherwise             if EMGLAB.matlab_version<7                enable='off';            else                enable='inactive';            end            h = uicontrol ('style', 'pushbutton', 'enable', enable, varargin{:});            region ('mcbutton', get(h, 'pos'), h);    end;    function region (type, position, id);    global SCREEN    n = length(SCREEN.region);    SCREEN.region(n+1).type = type;    SCREEN.region(n+1).id = id;    SCREEN.region_position(n+1,:) = position;function keyPress (src, evnt)    emgevent ('keypress', src, evnt);function scrollWheel(src,evnt)    emgevent('scrollwheel',src,evnt);