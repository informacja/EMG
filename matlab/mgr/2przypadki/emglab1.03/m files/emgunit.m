function op1 = emgunit (opt, p1, p2, p3)% Manages the templates and firing patterns.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	global DECOMP EMG SETS CURR    AVG_quality = 0;		switch lower(opt)		case 'init'		DECOMP = struct ('nunits', 0, 'unit', [], 'slist', [], ...            'compare_slist', [], 'closeup', [], 'dirty', 0, 'file', [], ...            'readonly', 0);        if isfield (EMG, 'rate');            if EMG.rate>0;            SETS.band(1).temp_width = goodwidth (...                emgprefs('muap_width'), 1/EMG.rate);            w = goodwidth (emgprefs('template_width'), 1/EMG.rate);            for i=2:SETS.nbands;                SETS.band(i).temp_width = w;            end;            end;        end;        emgslist ('init');        CURR.unit = 0;        CURR.annot_file = [];            case 'init channel'        DECOMP.nunits = 0;        DECOMP.unit = [];        DECOMP.closeup = [];        DECOMP.dirty = 0;        DECOMP.compare_slist = [];        emgslist ('init');        CURR.unit = 0;            case 'import' % p1=Ann, [p2 = filename]        Ann = p1;        if nargin<2; p2 = []; end;         temps = [];        tchans = [];        if isfield (Ann, 'template');            if Ann.template(1).rate == EMG.rate;                temps = [Ann.template(:).data];                tchans = [Ann.template(:).chan];                gains = [Ann.template(:).gain];            end;        end;        if isfield (Ann, 'chan');            currchan = CURR.chan;            for ic = 1:EMG.nchannels;                emgstatus ('change channel', ic);                i = find(Ann.chan ==ic);                sl =  [Ann.time(i), Ann.unit(i)];                ix = find(tchans==ic);                if ~isempty(ix);                    t = temps(:,ix) / gains(ix(1));                else                    t = [];                end;                emgunit ('init channel');                emgunit ('create', sl, t);                DECOMP.file = p2;                DECOMP.readonly = CURR.swap;            end;            emgstatus ('change channel', currchan);        elseif isfield (Ann, 'time');            sl =  [Ann.time, Ann.unit];            emgunit ('init channel');            emgunit ('create', sl, temps);            DECOMP.file = p2;            DECOMP.readonly = CURR.swap;        else                 sl = Ann;            emgunit ('init channel');            emgunit ('create', sl);             DECOMP.file = p2;            DECOMP.readonly = CURR.swap;        end;        	% 'create', [sl], [tp]%  creates one or more templates.%  sl can be a list of firing times or an slist%  tp can be an array of band-0 templates (if not present,%   templates will be formed by averaging)        case 'create'virtual = 0;if nargin<2; return;elseif isempty (p1) & nargin<3; return; elseif isempty (p1) & isempty(p2); return;elseif isempty (p1); sl = [nan,nan];elseif size(p1,2)==1; sl = [p1, ones(size(p1))];else sl = p1;end;if nargin<3; tp = [];elseif strcmp (p2, 'virtual');  tp = [];  virtual = 1;else tp = p2;end;[t0, t1] = whattime (SETS.firing);if t1-t0 > 10;	signal = emgsignal (t0, t1, 1);else    signal = emgresidual (t0, t1, 1);end;nu = max (max(sl(:,2)), size(tp,2));w = SETS.band(1).temp_width;w2 = SETS.band(CURR.band).temp_width;dt = 1/EMG.rate;for i=1:nu;    times = sl(sl(:,2)==i,1);    if size(tp,2)>=i;        template = mksig (tp(:,i), 0, dt, 2);        template = sigseg (template, 0, w, 'c');    elseif isempty(times)        template = grab (signal, nan, w);    elseif isnan(times) | isempty(times)        template = grab (signal, nan, w);    else        in_times = times;        ix = find(in_times>=t0 & in_times<=t1);         if isempty(ix);            signal_i = emgsignal (times(1) - w, times(end) + w, 1);         else            in_times = in_times(ix);            signal_i = signal;        end;        template = average (signal_i, in_times, w, w2, 'fast');    end;            iu = DECOMP.nunits + 1;    DECOMP.nunits = iu;    DECOMP.unit(iu).visible = 1;    DECOMP.unit(iu).waveform = template;                   t = rtp(template.sig);    DECOMP.unit(iu).waveform.interp = irtp(t,10);    emgunit ('filter', iu);    op1 = iu;    if isempty (t) | isnan(t) | virtual;    else        emgslist ('concat', [times, iu*ones(size(times))]);    end;    DECOMP.unit(iu).virtual = virtual;    DECOMP.unit(iu).map = 0;end;   case 'paste' % p1 = units;        unit = p1;        for i=1:length(p1);            unit(i).virtual = 0;            unit(i).map = 0;        end;        DECOMP.unit = [DECOMP.unit, unit];        DECOMP.nunits = length(DECOMP.unit);    case 'old create' % p1 = slist, [p2 = opt];        if nargin<2; sl = -1000; else sl = p1; end;        if isempty (sl); return; end;        if nargin<3; opt = 'normal'; else opt = p2; end;        if strcmp (opt, 'template');            unit = p1;            for i=1:length(p1);                unit(i).virtual = 0;                unit(i).map = 0;            end;            DECOMP.unit = [DECOMP.unit, unit];            DECOMP.nunits = length(DECOMP.unit);            return;        end;		[t0, t1] = whattime (SETS.firing);        if isempty(sl);             sl = [nan, 1];        elseif size(sl,2)==1;            sl = [sl, ones(size(sl))];        end;        for i = 1:max(sl(:,2));            tt = sl(sl(:,2)==i,1);            if ~isempty(tt);                 t = tt;                ix = find(t>=t0 & t<=t1);                 if isempty(ix);                    t0 = t(1) - SETS.band(1).temp_width;                    t1 = t(end) + SETS.band(1).temp_width;                else                    t = t(ix);                end;                if length(t)<10;                    resid = emgresidual (t0, t1, 1);                else                    resid = emgsignal (t0, t1, 1);                end;                iu = DECOMP.nunits + 1;                DECOMP.nunits = iu;                DECOMP.unit(iu).visible = 1;                if length(t)==1;                    DECOMP.unit(iu).waveform = grab (resid, t);                else                    DECOMP.unit(iu).waveform = average1 (resid, t);                end;                t = rtp(DECOMP.unit(iu).waveform.sig);                DECOMP.unit(iu).waveform.interp = irtp(t,10);                emgunit ('filter', iu);                op1 = iu;                if isnan(t) | strcmp (opt, 'virtual');                else                    emgslist ('concat', [tt, iu*ones(size(tt))]);                end;                DECOMP.unit(iu).virtual = strcmp(opt, 'virtual');                DECOMP.unit(iu).map = 0;            end;        end; %	case 'reconstruct'  % rebuilds DECOMP if it gets dinged.%        emgunit ('init channel');%		nu = emgslist ('how many');%		[t0, t1] = whattime (SETS.firing);%		sig = emgsignal (t0, t1, 1);%		for iu=1:nu;%			DECOMP.unit(iu).visible = 1;%			DECOMP.unit(iu).waveform = average (sig, emgslist(iu, t0, t1));%			t = rtp(DECOMP.unit(iu).waveform.sig);%			DECOMP.unit(iu).waveform.interp = irtp(t,10);%			emgunit ('filter', iu);%		end;%		DECOMP.nunits = nu;%		SETS.closeup.style = 'empty';	case 'reaverage'		if nargin<2; p1 = [1:DECOMP.nunits]; end;		[t0, t1] = whattime (SETS.firing);        sig = emgresidual (t0, t1, 1);        w = SETS.band(1).temp_width;        w2 = SETS.band(CURR.band).temp_width;		for iu=p1;			t = emgslist (iu, t0, t1);			if ~isempty(t);				avg = average (sig, t, w, w2);				x = DECOMP.unit(iu).waveform.sig + avg.sig;                n = min(length(x),100);				x = x - mean(x(1:n));                x = window (x);				DECOMP.unit(iu).waveform.sig = x;				DECOMP.unit(iu).waveform.interp = irtp(rtp(x),10);                if AVG_quality >1;                    t = rtp(x);                    sig = super (sig, avg, t, -1);                end;			end;		end;		emgunit ('filter', p1);            case 'center'        if nargin<2; p1 = [1:DECOMP.nunits]; end;        f = SETS.band(CURR.band).frequency;        for iu = p1;            x = DECOMP.unit(iu).waveform;            x = hpfilt (x, f);            [b, i]  = max(abs(x.sig));            off = i*x.dt + x.t0;            op1(iu) = -off;            emgunit ('shift', iu, -off);        end;       case 'resize'        if isfield (EMG, 'rate');            SETS.band(1).temp_width = goodwidth (...                emgprefs('muap_width'), 1/EMG.rate);            w = goodwidth (emgprefs('template_width'), 1/EMG.rate);            for i=2:SETS.nbands;                SETS.band(i).temp_width = w;            end;        end;        currchan = CURR.chan;        currswap = CURR.swap;        currcomp = CURR.compare;        emgcompare ('compare', 0); 		[t0, t1] = whattime (SETS.firing);        w = SETS.band(1).temp_width;        w2 = SETS.band(CURR.band).temp_width;        for ic = 1:EMG.nchannels;            emgvault ('channel', ic);            if DECOMP.nunits == 0;                n = -1;            elseif isempty(CURR.compare_file)                n = 0;            else                n = 1;            end;            for is = 0:n;                emgvault ('swap', is);    %%            sig = emgsignal (t0, t1, 1, ic);                for iu=1:DECOMP.nunits;    %%                s = emgslist (iu, t0, t1);    %%                if length(s)<4;    %%                    s = emgslist (iu);    %%                end;    %%                x = average (sig, s, w, w2);                    x = sigseg (DECOMP.unit(iu).waveform, 0, w, 'c');                    x.sig = window (x.sig);                    DECOMP.unit(iu).waveform = x;                    DECOMP.unit(iu).waveform.interp = irtp(rtp(x.sig),10);                end;                emgunit ('reaverage');                DECOMP.closeup = emgsnapshot ('filter', DECOMP.closeup);            end;        end;        emgvault ('channel', currchan);        emgvault ('swap', currswap);        emgcompare ('compare', currcomp);             case 'filter'		if nargin<2; p1 = [1:DECOMP.nunits]; end;		temp_width = SETS.band(CURR.band).temp_width;		freq = SETS.band(CURR.band).frequency;		for iu=p1;			w = DECOMP.unit(iu).waveform;			x = hpfilt (w, freq);			x = sigseg (x, 0, temp_width, 'c');            x.sig = window (x.sig);			t = rtp(x.sig);			DECOMP.unit(iu).tp = t;			DECOMP.unit(iu).interpolated = irtp(t,10);		end;	case 'shift'        emgslist ('shift', p1, p2);		w = DECOMP.unit(p1).waveform;		t = rtp(w.sig);		t = hr_shift(t, p2/w.dt);		DECOMP.unit(p1).waveform.sig = irtp(t);		DECOMP.unit(p1).waveform.interp = irtp(t,10);		emgunit ('filter', p1);		case 'delete'		if p1>DECOMP.nunits; return; end;		DECOMP.unit(p1) = [];		DECOMP.nunits = DECOMP.nunits - 1;        emgslist ('delete unit', p1);            case 'merge'		if p1>DECOMP.nunits | p2>DECOMP.nunits; return; end;        emgslist ('merge', p1, p2, p3);        DECOMP.unit(p1).visible = DECOMP.unit(p2).visible;        DECOMP.unit(p2) = [];        DECOMP.nunits = DECOMP.nunits - 1;         	case 'reorder'		DECOMP.unit = DECOMP.unit(p1);	        emgslist ('reorder', p1);	end;function avg = average (sig, slist, width, w2, opt)    if nargin<4; w2 = width/2; end;    if nargin<5; opt = 'normal'; end;    ensemble = sigseg (sig, slist(:,1), width, 'c');    ensemble = ensemble.sig;    ensemble = ensemble - mean(mean(ensemble));    if isempty(slist) | isnan(slist);        avg = zeros(round(width/sig.dt), 1);    elseif length(slist)==1;        i = round((width-w2)/sig.dt/2);        avg = ensemble - mean(ensemble);        avg = [zeros(i,1); window(avg(i+1:end-i)); zeros(i,1)];    elseif strcmp (opt, 'fast');        avg = median(ensemble,2);        avg = avg - mean(avg);        avg = window(avg);    else        n = size(ensemble,2);        if n<3;            nextra = 0;        elseif n<5;            nextra = 1;        else            nextra = 2;        end;        ensemble (:,floor(n+nextra)) = 0;        wcoef = wt (ensemble, 4);        if n > 20;           s = sort(wcoef,2);           f = round(n/10);           medwcoef = mean(s(:,f:end-f+1),2);        else           medwcoef = median(wcoef,2);        end;        avg = iwt (medwcoef, 4);    end;    avg = mksig (avg, 0, sig.dt, 2);function avg = joe_average (sig, slist, width)    if isempty(slist);        l = round(width/sig.dt);        avg = mksig (zeros(l,1), 0, sig.dt, 2);        return;    end	ensemble = sigseg (sig, slist(:,1), width, 'c');	ensemble = ensemble.sig;    n = size(ensemble,2);    if n<3;        nex = 0;    elseif n<5;        nex = 1;    else        nex = 2;    end;    ensemble (:,floor(n+nex)) = 0;    wcoef = wt (ensemble, 4);    if n > 20;       s = sort(wcoef,2);       f = round(n/10);       medwcoef = mean(s(:,f:end-f+1),2);    else       medwcoef = median(wcoef,2);    end;        w = iwt (medwcoef, 4);	avg = mksig (w, 0, sig.dt, 2);	function avg = average1 (sig, slist, width)	ensemble = sigseg (sig, slist(:,1), width, 'c');    avg = median(ensemble.sig,2);    avg = avg - mean(avg);    avg = mksig (window(avg), 0, sig.dt, 2);    function s = grab (sig, t, width)		global SETS CURR EMG    if isnan(t);        i = round(width*EMG.rate);        s = mksig (zeros(i,1), 0, 1/EMG.rate, 2);    else        s = sigseg (sig, t, width, 'c');        i = round((width-SETS.band(CURR.band).temp_width)/s.dt/2);        x = s.sig;        x = x - mean(x);        x = [zeros(i,1); window(x(i+1:end-i)); zeros(i,1)];        s = mksig (x, 0, s.dt, 2);    end;    function x = window (x)    k = floor (length(x)/10);    w = (1-cos(pi*[1:k]'/k))/2;    x(1:k) = x(1:k).*w;    x(end:-1:end-k+1) = x(end:-1:end-k+1).*w;