function emgbutton (panel, button)% EMGlab function that handles button  presses.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	global CURR SETS EMG DECOMP 	if isempty(EMG.data); return; end;     %	if nargin==0;%		panel = get (gcbo, 'tag');%		button = get (gcbo, 'string');%	end		switch panel		case 'signal';  		S = SETS.signal; 		switch button;				case '<';				emgcursors ('focus', 'signal', '<');		case '>';         			emgcursors ('focus', 'signal', '>');              		case '| |'            emgcursors ('timebase', 'signal', '| |');            return;			[t0, t1] = whattime (S);			focus = SETS.closeup.time;						if isempty(focus) | focus<t0 | focus > t1;				focus = (t0+t1)/2;			end;						offset = (focus-t0) / S.timebase;			SETS.signal.timebase = bump (S.timebase, S.tbase_list, -1);			SETS.template.timebase = SETS.signal.timebase; 			emgcursors ('focus', 'signal', 'z', focus - offset*SETS.signal.timebase);			emgplot ('templates');		case '|||'            emgcursors ('timebase', 'signal', '|||');            return;			[t0, t1] = whattime (S);			focus = SETS.closeup.time;						if isempty(focus) | focus<t0 | focus > t1;				focus = (t0+t1)/2;			end;						offset = (focus-t0) / S.timebase;			tbmax = EMG.duration/(S.right - S.left);			SETS.signal.timebase = bump (S.timebase, S.tbase_list, +1, tbmax);			SETS.template.timebase = SETS.signal.timebase;            SF = SETS.firing;            if SETS.signal.timebase*(S.right-S.left) > SF.timebase*(SF.right-SF.left);                emgbutton ('firing', '|||');                emgcursors ('focus', 'signal', 'z', focus - offset*SETS.signal.timebase, 1);            else                emgcursors ('focus', 'signal', 'z', focus - offset*SETS.signal.timebase, 1);            end;			emgplot ('templates');   		case '-'			SETS.signal.sensitivity(CURR.chan, CURR.band) = ...				bump (S.sensitivity(CURR.chan, CURR.band), S.sens_list, +1);            SETS.navigation.sensitivity(CURR.chan, CURR.band) = ...                SETS.signal.sensitivity(CURR.chan, CURR.band);			emgplot ({'signal', 'navigation'});		case '+'			SETS.signal.sensitivity(CURR.chan, CURR.band) = ...				bump (S.sensitivity(CURR.chan, CURR.band), S.sens_list, -1);            SETS.navigation.sensitivity(CURR.chan, CURR.band) = ...                SETS.signal.sensitivity(CURR.chan, CURR.band);			emgplot ({'signal', 'navigation'});		end;			case 'template';  		S = SETS.template;               		switch button;          		case '<'            step = min (ceil(S.display/2), 10);			SETS.template.first_unit = max (S.first_unit - step, 1);                  emgplot ({'templates', 'firing'});		case '>'			step = min (ceil(S.display/2), 10);			f = min (S.first_unit + step, DECOMP.nunits - S.display + 1);			SETS.template.first_unit = max (f, 1);               emgplot ({'templates', 'firing'});		case '| |'            if CURR.unit>0;                p = (CURR.unit - S.first_unit+1)/S.display;                SETS.template.display = bump (S.display, S.display_list, -1);                 k = ceil (p*SETS.template.display);                SETS.template.first_unit = CURR.unit -k + 1;            else                SETS.template.display = bump (S.display, S.display_list, -1);             end;                            emgplot ({'templates', 'firing'}); 		case '|||'			if DECOMP.nunits > S.display | S.display < 10;	            SETS.template.display = bump (S.display, S.display_list, +1);			end;			f = min (S.first_unit, DECOMP.nunits - SETS.template.display + 1);			SETS.template.first_unit = max (f, 1);	             emgplot ({'templates', 'firing'});		case '-'            SETS.template.sensitivity(CURR.chan, CURR.band) = ...				bump (S.sensitivity(CURR.chan, CURR.band), S.sens_list, +1);	            emgplot ('templates');		case '+'            SETS.template.sensitivity(CURR.chan, CURR.band) = ...				bump (S.sensitivity(CURR.chan, CURR.band), S.sens_list, -1);            emgplot ('templates');		end;          		case 'firing'		S = SETS.firing;		switch button;				case '<';				emgcursors ('focus', 'firing', '<');		case '>';				emgcursors ('focus', 'firing', '>');		case '| |'            emgcursors ('timebase', 'firing', '| |');            return            tb = SETS.firing.timebase;			[t0, t1] = whattime (SETS.firing);            [ts0, ts1] = whattime (SETS.signal);			focus = (ts0 + ts1)/2;						if isempty(focus) | focus<t0 | focus > t1;				focus = (t0+t1)/2;			end;						offset = (focus-t0) / S.timebase;			SETS.firing.timebase = bump (S.timebase, S.tbase_list, -1);            if SETS.firing.timebase == tb; return; end;            emgcursors ('focus', 'firing', 'z', focus - offset*SETS.firing.timebase, 1);            SS = SETS.signal;            if SS.timebase*(SS.right-SS.left) > SETS.firing.timebase*(S.right-S.left);                emgbutton ('signal', '| |');                emgcursors ('focus', 'signal', 'c', focus, 1);            end;            if SETS.firing.timebase <=1 & SETS.navigation.timebase >1;                emgbutton ('navigation', '| |');            end;              		case '|||'            emgcursors ('timebase', 'firing', '|||');            return;            tb = SETS.firing.timebase;			[t0, t1] = whattime (SETS.firing);            [ts0, ts1] = whattime (SETS.signal);			focus = (ts0 + ts1)/2;						if isempty(focus) | focus<t0 | focus > t1;				focus = (t0+t1)/2;			end;						offset = (focus-t0) / S.timebase;			tbmax = EMG.duration/(S.right - S.left);			SETS.firing.timebase = bump (S.timebase, S.tbase_list, +1, tbmax);            if SETS.firing.timebase==tb;                 return;             elseif SETS.firing.timebase == SETS.signal.timebase;                emgcursors ('focus', 'firing', 'l', SETS.signal.time, 1);            else                           emgcursors ('focus', 'firing', 'z', focus - offset*SETS.firing.timebase, 1);            end;            if SETS.firing.timebase > SETS.navigation.timebase;                emgbutton ('navigation', '|||');            end;		case '-'            if strcmp (S.style, 'ifr');                SETS.firing.sensitivity = bump (S.sensitivity, S.sens_list, +1);                emgplot ('firing');            end;		case '+'            if strcmp (S.style, 'ifr');                SETS.firing.sensitivity = bump (S.sensitivity, S.sens_list, -1);                emgplot ('firing');            end;		case 'o'			if strcmp(S.style, 'normal');				SETS.firing.style = 'ifr';			else				SETS.firing.style = 'normal';			end;			emgplot ('firing');		end;		case 'closeup';  		S = SETS.closeup;		switch button;		case '<';			emgcursors ('focus', 'closeup', '<');		case '>'			emgcursors ('focus', 'closeup', '>');		case '| |'            emgcursors ('timebase', 'closeup', '| |');		case '|||'            emgcursors ('timebase', 'closeup', '|||');            return;		case '-'					SETS.closeup.sensitivity(CURR.chan, CURR.band) = ...				bump (S.sensitivity(CURR.chan, CURR.band), S.sens_list, +1);            emgplot ('closeup');		case '+'			SETS.closeup.sensitivity(CURR.chan, CURR.band) = ...				bump (S.sensitivity(CURR.chan, CURR.band), S.sens_list, -1);            emgplot ('closeup');		case 'R'			emgaction ('resolve closeup');		case 'OK'			switch S.style;			case 'normal'				emgaction ('accept closeup');			case 'merge'				emgaction ('accept merge');			end;		case 'x'			switch S.style			case 'normal'				DECOMP.closeup = emgsnapshot ('snap', SETS.closeup.time);                emgplot ('closeup');			case 'merge'				SETS.closeup.style = 'empty';				emgplot ({'firing', 'closeup'});			end;		end;		case 'navigation'        switch button;			case '<';            SETS.navigation.time_step=1;			emgcursors ('focus', 'navigation', '<');					case '>';            SETS.navigation.time_step=1;			emgcursors ('focus', 'navigation', '>');        case '| |';            emgcursors ('timebase', 'navigation', '| |');        case '|||';            emgcursors ('timebase', 'navigation', '|||');        end;		case 'filter'        i = get (gcbo, 'value');        if i==SETS.nbands+1;            go = 1;            while go;                d = [];                d = clerk ('add', d, 'frequency', 'int', SETS.band(2).frequency, {}, 1, 'Cutoff frequency');                [d, status] = gendialog (d, 'EMGlab highpass filter', emgprefs('font_size'));                if ~status;                     emgsettings ('set popups');                    return;                end;                f = d.frequency.value;                if f<=0 | f >= 1/2*EMG.rate;                    uiwait (warndlg ('Frequency must be >0 and < sampling rate / 2', 'EMGlab', 'modal'));                else                    go = 0;                end;            end;            i = 2;            SETS.band(i).frequency = d.frequency.value;            CURR.band = i;            emgsettings ('set popups');                    end;        emgaction ('select filter', i);			case 'channel'		emgaction ('select channel', get(gcbo, 'value'));            case 'lowpass'        emgplot ('firing');                    case 'map'        switch button;        case '<<'            emgcursors ('focus', 'signal', 'l', EMG.start);        case 'P'            emgplay ('start');        end;	end;function val = bump (val, list, inc, vmax);	if isnan(val); return; end;	i = min(find(val<=list));	if inc>0;		if nargin>=4;			list = list(list<=vmax);		end;		i = min(i+inc, length(list));	else		i = max(i+inc, 1);	end;	val = list(i); 	