function plotscale (K, S, xstyle, ystyle, varargin);% Plots the time scales for emgplot.% Copyright (c) 2006. Kevin C. McGill and others.% Part of EMGlab version 0.9.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.stanford.edu    global CURR SETS    large_tick = 8;    C = SETS.colors;	if ~isstruct(S); return; end;    c = get(K.axes, 'ch');    if strcmp (CURR.draw_mode, 'smoother');        type = 1;    elseif strcmp (get(c(end), 'vis'), 'off')        type = 2;    else        type = 3;    end;			pos = get (K.axes, 'position');	xdivs_per_pixel = abs(S.right - S.left) / pos(3);		ydivs_per_pixel = abs(S.top - S.bottom) / pos(4);            if nargin==3;        t0 = S.time + S.left*S.timebase;        t1 = S.time + S.right*S.timebase;            [t, ttick, tlabel, tlabels] = tickify (t0, t1, S.right-S.left, pos(3), xstyle);        for i=1:length(tlabel);            myset (K.scale(i), type, 'str', tlabels{i});        end;        return;    end;    	t0 = S.time + S.left*S.timebase;	t1 = S.time + S.right*S.timebase;    if size(S.sensitivity,2)>1;        sens = S.sensitivity(CURR.chan, CURR.band);    else        sens = S.sensitivity;    end;    v0 = S.bottom * sens;    v1 = S.top * sens;        [t, ttick, tlabel, tlabels] = tickify (t0, t1, S.right-S.left, pos(3), xstyle);    [v, vtick, vlabel, vlabels] = tickify (v0, v1, S.top-S.bottom, pos(4), ystyle);    t = S.left + (t - t0)/(t1-t0)*(S.right-S.left);    v = S.bottom + (v-v0) / (v1-v0) * (S.top - S.bottom);   switch xstyle         case 'major';            itmaj = find(ttick==max(ttick));            itmin = find(ttick<max(ttick));        case 'medium';            itmaj = find(ttick>min(ttick));            itmin = find(ttick==min(ttick));        otherwise            itmaj = [];            itmin = [];        end;    switch ystyle        case 'major';            ivmaj = find(vtick==max(vtick));            ivmin = find(vtick<max(vtick));        case 'medium';            ivmaj = find(vtick>min(vtick));            ivmin = find(vtick==min(vtick));        otherwise            ivmaj = [];            ivmin = [];        end;                if S.grid;                tx = [t; t; t];        ty = S.bottom + [0*ttick; ttick./ttick; nan*ttick] * (S.top - S.bottom);        vy = [v; v; v];        vx = S.left + [0*vtick; vtick./vtick; nan*vtick] * (S.right - S.left);                x1 = tx(:,itmaj);        x2 = vx(:,ivmaj);        y1 = ty(:,itmaj);        y2 = vy(:,ivmaj);        if length(varargin{1})<5;        myset (K.grat(2), type, 'xdata', [x1(:); nan; x2(:)], 'ydata', [y1(:); nan; y2(:)], ...            'color', .4*C.graticule + .6*C.panel);        end;                x1 = tx(:,itmin);        x2 = vx(:,ivmin);        y1 = ty(:,itmin);        y2 = vy(:,ivmin);        if length(varargin{1})<5;        myset (K.grat(1), type, 'xdata', [x1(:); nan; x2(:)], 'ydata', [y1(:); nan; y2(:)], ...            'color', .2*C.graticule + .8*C.panel);        end;        xtext_off = large_tick * ydivs_per_pixel/2;        ytext_off = large_tick * xdivs_per_pixel/2;         %       myset (K.grat1, type, 'xdata', nan, 'ydata', nan);           else        xtext_off = large_tick * ydivs_per_pixel;        ytext_off = large_tick * xdivs_per_pixel;        X = [];        Y = [];        tx = [t; t; t];        ty = [0*ttick; ttick*ydivs_per_pixel; nan*ttick];        vy = [v; v; v;];        vx = [0*vtick; vtick*xdivs_per_pixel; nan*vtick];        for i=1:length(varargin);            [axis_dir, p0, tick_dir, text_location] = deal (varargin{i}{:});                    switch axis_dir;                            case 'x'                X = [X; nan; tx(:)];                Y = [Y; nan; p0 + tick_dir*ty(:)];                            case 'y'                X = [X; nan; p0 + tick_dir*vx(:)];                Y = [Y; nan; vy(:)];            end;        end;         if length(varargin{i})<5;        myset (K.grat(1), type, 'xdata', X, 'ydata', Y, 'color', C.graticule);        myset (K.grat(2), type, 'xdata', nan, 'ydata', nan);        end; %       myset (K.grid2, type, 'xdata', nan, 'ydata', nan);           end;    ip = 0;    for i=1:length(varargin);        [axis_dir, p0, tick_dir, text_location] = deal (varargin{i}{:});        if strcmp (text_location, 'none')        elseif strcmp (axis_dir, 'x');                      x = S.left + (tlabel-t0)/(t1-t0)*(S.right-S.left);            if strcmp (text_location, 'above');                y = p0 + max(tick_dir,0)*xtext_off + 2*ydivs_per_pixel;                v_align = 'base';                h_align = 'cen';            elseif strcmp (text_location, 'below');                y = p0 + min(0,tick_dir)*xtext_off - 2*ydivs_per_pixel;                v_align = 'top';                h_align = 'cen';            else                y = p0 + tick_dir * xtext_off/2;                v_align = 'base';                h_align = 'left';                x = x + 2*xdivs_per_pixel;            end;            n = length(tlabel);            for i=1:n;                myset (K.scale(ip+i), type, 'pos', [x(i), y], 'str', tlabels{i}, ...                    'horiz', h_align, 'vert', v_align);            end;            e = get(K.scale(ip+1),'extent');            if e(1)<S.left;                p = get(K.scale(ip+1), 'pos');                set (K.scale(ip+1), 'pos', p + [S.left-e(1), 0, 0]);            end;            e = get(K.scale(ip+n),'extent');            if e(1)+e(3)>S.right;                p = get(K.scale(ip+n), 'pos');                set (K.scale(ip+n), 'pos', p + [S.right-e(1)-e(3), 0, 0]);            end;                ip = ip+n;                    elseif strcmp (axis_dir, 'y');            y = S.bottom + (vlabel - v0)/(v1-v0)*(S.top-S.bottom);            labels = vlabels;  %          tick = large_tick * xdivs_per_pixel;            if strcmp (text_location, 'corner');                y= y([1,end]);                labels = labels([1,end]);                h_align = 'right';                v_align = 'top';                x = p0 - ytext_off - 2*xdivs_per_pixel;            elseif strcmp (text_location, 'left');                h_align = 'right';                v_align = 'middle';                x = p0 + min(0,tick_dir)*ytext_off -2*xdivs_per_pixel;            elseif strcmp (text_location, 'right');                h_align = 'left';                v_align = 'middle';                x = p0 + max(0,tick_dir)*ytext_off + 2*xdivs_per_pixel;            end;            n = length(y);            for i=1:n;                myset (K.scale(ip+i), type, 'pos', [x, y(i)], 'str', labels{i}, ...                    'horiz', h_align, 'vert', v_align, 'clipping', 'off');            end;            e = get (K.scale(ip+1), 'extent');            if e(2)<S.bottom;                p = get (K.scale(ip+1), 'pos');                set (K.scale(ip+1), 'pos', p + [0, S.bottom - e(2), 0]);            end;            e = get (K.scale(ip+n), 'extent');            if e(2)+e(4)>S.top;                p = get (K.scale(ip+n), 'pos');                set (K.scale(ip+n), 'pos', p + [0, S.top - e(2) - e(4), 0]);            end;            ip = ip + n;        end;        myset (K.scale(ip+1:end), type, 'str', ' ');    end;                                function [x, y, x_label, label]  = tickify (u0, u1, n_divs, n_pixels, style);    large_tick = 8;	middle_tick = 5;	small_tick = 3;                k = log((u1 - u0)/n_divs)/log(10);    k_exp = floor(k);    k_mantissa = k - k_exp;    if k_mantissa < 0.2;        div = 10^k_exp;        n_medium_ticks = 2;    elseif k_mantissa < 0.48;        div = 2*10^k_exp;        n_medium_ticks = 2;    elseif k_mantissa < 0.84;        div = 5*10^k_exp;        n_medium_ticks = 5;    else        k_exp = k_exp+1;        div = 10^k_exp;        n_medium_ticks = 2;    end;    precision = max(-k_exp, 0);    	U0 = ceil(u0/div)*div;	U1 = floor(u1/div)*div;            pixels_per_div = div / (u1-u0) * n_pixels;            if pixels_per_div/10 > 10;        n_minor_ticks = 10;    elseif pixels_per_div/n_medium_ticks >10        n_minor_ticks = n_medium_ticks;    else        n_minor_ticks = 1;        n_medium_ticks = 1;    end;    u = [U0-div : div/n_minor_ticks: U1+div];    i = find (u>=u0 & u<=u1);    y = ones(size(u)) * small_tick;    y(1:n_minor_ticks/n_medium_ticks:end) = middle_tick;    y(1:n_minor_ticks:end) = large_tick;    x = u(i);    y = y(i);    if strcmp (style, 'major');        i = find(y==large_tick);    elseif strcmp (style, 'medium');        i = find(y>=middle_tick);        if k_mantissa < 0.2;            precision = max(-k_exp+1, 0);        end;    else        i = [];    end;    label = {};    x_label = x(i);    format = sprintf('%%.%if', precision);    for i=1:length(x_label);        label{i} = sprintf(format, x_label(i));    end;            function myset (h, type, varargin);        switch type            case 1                set (h, varargin{:}, 'vis', 'on');            case 2                set (h, varargin{:}, 'vis', 'off');            case 3                set (h, 'erase', 'back');                set (h, varargin{:}, 'erase', 'none', 'vis', 'off');        end;