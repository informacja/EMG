function status = mtlplugin (opt, p1)% MTLEMG plugin for EMGlab.% Adds "Auto decomp (MTL)" and "Resolve closeup (MTL) to Analyze mentu% Copyright (c) 2007-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net    global EMGLAB EMG SETS CURR DECOMP    if isempty (EMGLAB); return; end;    if nargin==0; opt='init'; end;        switch opt            case 'init'          vPat = fileparts(which('mtlemg'));        v = version;        if v(1)<'7';            warndlg ({'The MTL plugin cannot be loaded.', ...                'It requires Matlab version 7.0 or higher.'}, ...                'EMGlab');             %rmpath (fullfile(EMGLAB.path, 'mtlemg'));             status = 0;             return;        end;        if strcmp(computer, 'PCWIN')            addpath(fullfile(vPat, 'dll files'));        else            addpath(fullfile(vPat, 'm files'));        end        if ~exist('interp')            addpath(fullfile(vPat, 't files'));        end                emgprefs ('add', 'MTL_allow_ga', 'double', 0, {}, 1, 'MTL: use Genetic Alg');        status = 1;            case 'menu'        p = findobj (p1, 'type', 'uimenu', 'label', 'Analyze');        h = findobj (p, 'type', 'uimenu', 'label', 'Show all');        pos = get (h, 'position');        uimenu (p, 'label', 'Auto Decomp (MTL)', 'separator', 'on', ...            'position', pos+1, 'callback', 'mtlplugin(''auto decomp'')');        uimenu (p, 'label', 'Resolve Closeup (MTL)', ...            'position', pos+2, 'callback', 'mtlplugin(''resolve'')');                    case 'auto decomp'                   if isempty (EMG.data); return; end;        if DECOMP.nunits>0;            r = questdlg ('Delete current annotation and reanalyze?', 'EMGlab');            if ~strcmp (lower(r), 'yes'); return; end;        end;           emgvault ('remember', 'Auto decomp (MTL)');        SETS.closeup.style = 'empty';        SETS.firing.style = 'normal';        SETS.template.first_unit = 1;        CURR.unit = 0;        CURR.swap = 0;        CURR.compare = 0;        emgunit ('init');        emgcompare ('init');        emgvault ('delete all');    	emgplot;        emgplot ('busy');        		DECOMP.dirty = 1;		[t0, t1] = whattime (SETS.firing);                sig = [];        current_chan = CURR.chan;        s = emgsignal (t0, t1);        s = zeros(length(s.sig), EMG.nchannels);        for ic=1:EMG.nchannels;            s = emgsignal (t0, t1, CURR.band, ic);            sig(:,ic) = s.sig;        end;		c = mtlemg (sig, EMG.rate, emgprefs ('MTL_allow_ga'));        if isempty (c); return; end;        for ic = 1:EMG.nchannels;            emgvault ('channel', ic);            sl = c{ic};            sl(:,1) = sl(:,1) + t0;            emgunit ('create', sl);        end;        emgvault ('channel', current_chan);        emgsettings ('show all templates');        emgplot ({'signal', 'templates', 'firing', 'navigation', 'done'});                     case 'resolve';        if isempty(DECOMP.closeup); return; end;        if isempty(DECOMP.closeup.comp); return; end;        if ~strcmp(SETS.closeup.style, 'normal');  return; end;        emgvault ('remember', 'Resolve closeup (MTL)');        emgplot ('busy');        p1 = DECOMP.closeup;                if p1.filter ~= SETS.band(CURR.band).frequency;            p1 = emgsnapshot ('filter', p1);        end;		ss = p1;		comp = ss.comp;        if ~isempty(comp);		[b,s]  = emgsnapshot ('waves', ss);		ix = find([comp(:).visible]>0 & ~isnan([comp(:).time]));           if ~isempty(ix);			d = ([comp(ix).time]-ss.t0)*EMG.rate;			temps = irtp(hr_shift(emgtemp ([comp(ix).unit]), d));              a = mtlresolve(s.sig, temps, EMG.rate);            for i=1:length(a);               if ~isnan(a(i));                    ss.comp(ix(i)).time = comp(ix(i)).time + a(i)/EMG.rate;                end;            end;            b = find(isnan(a));            ss.comp(ix(b)) = [];                    end;        end;		DECOMP.closeup = ss;        emgplot ({'closeup signals', 'done'});                              end;        