function x = iwt (w, L, opt);% IWT   Inverse wavelet transform.%	IWT(W,L) inverts the wavelet transform obtained by wt.%%	The boundary values are corrected so that iwt and wt are%	numeric inverses. This is not based on Wavelab, and may not %	be theoretically sound.%%	IWT(W,L,1) inverts the spin-cycle transform.% Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	if length(w) < 2^(L+1);		error ('Input length must be at least 2^(L+1).');	end;	[q, qmr, l1, r1, r2, ls, rs] = get_constants;					if nargin==2;		% Normal transform		lx = size(w,1);		for i=1:L;			ld(i) = ceil((lx-1)/2);			lx = ceil(lx/2);		end;		x = w(end-lx+1:end,:);		for j=L:-1:1; 			x1 = filter (q, 1, upsample(x));			t = w(end-lx-ld(j)+1:end-lx, :); 			x2 = filter (qmr, 1, upsample(t));			lx = lx + ld(j);			x = x1(5:4+lx,:) + x2(5:4+lx,:);			x(1:3,:) = l1 * x(1:3,:);			if size(x1,1) == size(x2,1);				x(end-2:end,:) = r1 * x(end-2:end,:);			else				x(end-3:end,:) = r2 * x(end-3:end,:);			end;		end		else			% Spin cycle transform		if size(w,2)~=L+1			error ('Input must have L+1 columns for spin cycle');		end;		x = w(:,L+1);  		for j = L: -1: 1;			s = 2^(j-1);			for k = 0: s-1;				x1 = conv (q, x(k+1:s:end));				x2 = conv (qmr, w(k+1:s:end,j));				y = x1(4:end-4) + x2(5:end-3);				y(1:4) = ls * y(1:4);				y(end-3:end) = rs* y(end-3:end);				x(k+1:s:end) = y;			end;		end;	end;function y = upsample (x);    [r,c] = size(x);	y = zeros(2*r+7,c);	y(2:2:end-7,:) = x;	function [q, qmr, l1, r1, r2, ls, rs] = get_constants ();		q = [ -0.07576571478934; -0.02963552764595;  0.49761866763246; ...		   0.80373875180522;  0.29785779560554; -0.09921954357694; ...		  -0.01260396726226;  0.03222310060407];	qmr = q(8:-1:1).*[-1;1;-1;1;-1;1;-1;1];	l1 = [ 0.93299669024904,  0.01504342721716, -0.03845978480962; ...		  -0.01524332456593,  1.00079951449102, -0.00204402592793; ...		   0.03897083916643, -0.00204402592792,  1.00522572391243];	r1 = [ 1.02103703821690,  0.00822857316667, -0.34459615132982; ...		   0.00822857316662,  1.00321858123091, -0.13478773080664; ...		  -0.12089503878637, -0.04728772472078,  2.93279516808396];	r2 = [ 1.00103043745532,  0.00040305245955, -0.00318914558527, ...		   0.00201300224947;  0.00040305245954,  1.00015765273701, ...		  -0.00124742454326,  0.00078737967426; -0.00214794124222, ...		  -0.00084016064852,  1.01317972637032, -0.11397587996832; ...		  -0.00912406700370, -0.00356885090672,  0.03079343083727, ...		   0.93923572890994];	ls = [ 1.22001584435799, -0.00996468046878, -0.02732817315176, ...		   0.00587932727994; -0.07737806798161,  1.00954397562660, ...		   0.00102441547460, -0.00198641032811;  0.01389178110540, ...		  -0.00082230513171,  1.00317025617591, -0.00013580324298; ...		   0.02949911423818, -0.00185445979713, -0.00086352430780, ...		   1.00066421360067];   	rs = [ 1.00051521379216,  0.00017094633542, -0.00160192487077, ...		   0.00141975088521;  0.00060174558328,  1.00533604017603, ...		   0.00003259462286, -0.08279564768581; -0.00104293000509, ...		   0.00336105116215,  1.00794490153193, -0.11840299473451; ...		  -0.00685481637445, -0.03186242232911,  0.01161800518856, ...		  1.42243902895643];