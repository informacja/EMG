function [sigout, sigouttp] = sigseg (signal, t, seglen, opt)% SIGSEG 	Extract segments from a signal%	OUTPUT = SIGSEG (INPUT, T, L) extracts the segment of length L from the%	vector INPUT starting at index T. If T is a vector, then OUTPUT has one %	column for each value of T. Values that fall outside the length of INPUT%	are set to zero.%%	INPUT can be a struct with fields 'sig', 't0', 'dt', or a cell array of the%	form {SIG, T0, DT}, where SIG is a data vector, T0 is the time associated %	with the first element of SIG, and DT is the time interval between the%	elements of SIG. In this case, T and L are interpreted with respect to T0%	and DT without interpolation and OUTPUT is returned as a struct. %%	SIGSEG (INPUT, T, L, 'c') causes the segments to be centered on times T. %	In this case if the elements of T do not correspond to integer indices, %	then interpolation is performed using trigonometric polynomials.%%	[OUTPUT, OUTTP] = SIGSEG (...) also returns the trigonmetric polynomial %	representations of the segments. % Copyright (c) 2006-2009. Kevin C. McGill and others.% Part of EMGlab version 1.0.% This work is licensed under the Aladdin free public license.% For copying permissions see license.txt.% email: emglab@emglab.net	if nargin==3;		center = 0;	elseif lower(opt) =='c';		center = 1;	else		error ('Unknown option.');	end;    if isnan(t); t=[]; end;		[sig, start, dt, structout] = sigsep (signal);	nsegs = length(t);	nsamps = round (seglen/dt);	gottp = 0;	if center		ibeg = round((t - start)/dt) - floor(nsamps/2);		iend = ibeg + nsamps - 1;	else		ibeg = round((t - start)/dt);		iend = ibeg + nsamps - 1;	end;	sigout = zeros (nsamps, nsegs);		ibegi = max (ibeg, 0) + 1;	iendi = min (iend, length(sig)-1) + 1;		ibego = ibegi - ibeg;	iendo = iendi - ibeg;		for i=1:nsegs;		sigout(ibego(i):iendo(i),i) = sig(ibegi(i):iendi(i));	end;    off = 0;    if center		tx = (t - start) / dt;		if any(abs(tx - round(tx)) > 1/20);            off = tx - round(tx);			sigouttp = rtp (sigout);			sigouttp = hr_shift (sigouttp, -off);			sigout = irtp (sigouttp);			gottp = 1;        end;	end;	if nargout==2 & ~gottp;		sigouttp = rtp (sigout);	end;	if structout		sigout = struct ('sig', sigout, 't0', start + (ibeg+off)*dt, 'dt', dt);	end;